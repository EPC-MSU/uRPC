<%namespace file="handlers.h.mako" import="get_struct_type"></%namespace>\
<%namespace file="handlers.h.mako" import="get_struct_code_ac"></%namespace>\
<%namespace file="handlers.h.mako" import="get_struct_code"></%namespace>\
<%namespace import="namespaced" module = "urpc.builder.device.utils.namespaced" inheritable="True"/>\
/*
 * Each file must start with this include.
 * File containes global settings.
 */
#include "settings.h"

/*
 * Main includes here.
 */
#include "flowparser.h"

/*
 * This file is autogenerated.
 * Changes made to this file can be overwritten.
 */

/*
 * Other includes here.
 */
#include <string.h>     // Required for memcpy()
#include "atomicrun.h"
#include "commands.h"   // Protocol definitions
#include "handlers.h"
#include "macro.h"
#include "algorithm.h"  // Required for CRC16

#if defined(__cplusplus)
extern "C"
{
#endif

typedef struct
{
  union
  {
    uint8_t Array[_PACKET_LENGTH];
    struct
    {
      uint32_t  Command;
      uint8_t   Data[_PACKET_LENGTH - _COMMAND_LENGTH];
    };
  };
  uint16_t Size;

} packet_t;

static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output);

/*
 * This function gets a command-packet structure
 * and puts into response command-packet.
 * The Array size must be enough to hold any single response.
 */
static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output)
{
  /*
   * Each transmit starts with command code. Just copy...
   * After that find packet size in table and paste to the structure.
   */
  Output->Command = Input->Command;
  Output->Size    = Commands_GetOutputSize(Output->Command);

  /*
   * Check ERRC state. Checking is based on the return
   * value of the function Commands_GetOutputSize(...).
   * See description Commands_GetOutputSize(...) for more information.
   */
  if (Output->Size == 0)
  {
    Output->Command = ERRC_CMD;
    Output->Size    = _COMMAND_LENGTH;
    return;
  }

  /*
   * Check ERRD state.
   */
  if (Input->Size > _COMMAND_LENGTH)  // If there is some data
  {
#ifdef DEBUG
    if (Input->Size <= _COMMAND_LENGTH + _CRC_LENGTH)   // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint8_t   CheckCode[_CRC_LENGTH];
    uint16_t  InputFieldsSize = Input->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes from the end of packet (after input fields).
     *
     * Cortex-M0+ doesn't support unaligned memory access. We must copy
     * the CRC16 bytes by byte.
     *
     * See:
     *   - http://infocenter.arm.com/help/topic/com.arm.doc.dui0662b/BABFAIGG.html
     *   - http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/BABFAIGG.html
     */
    for (uint32_t Index = 0; Index < _CRC_LENGTH; Index++)
    {
      CheckCode[Index] = *(uint8_t *)(Input->Data + InputFieldsSize + Index);
    }

    /*
     * Calc and check CRC16.
     */
    if (*(uint16_t *)CheckCode != Algorithm_CRC16(Input->Data, InputFieldsSize, ALGORITHM_CRC16_SEED))
    {
      Output->Command = ERRD_CMD;
      Output->Size    = _COMMAND_LENGTH;
      return;
    }
  }

  /*
   * If in the end ErrorValue is non zero, it means that a value
   * came out of the range and has been corrected.
   */
  int32_t ErrorValue = 0;

  uint8_t DataDuplicate[_PACKET_LENGTH - _COMMAND_LENGTH];

  switch (Input->Command)
  {
    /*
     * Regular commands with input data must be below.
     */
  %for cmd in view.regular_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    memcpy(DataDuplicate, Input->Data, sizeof(${get_struct_type(cmd.request)}));
    %if len(cmd.response.args) != 0:
    on_${namespaced(cmd.name)}((${get_struct_type(cmd.request)} *)DataDuplicate, (${get_struct_type(cmd.response)} *)Output->Data);
    %else:
    on_${namespaced(cmd.name)}((${get_struct_type(cmd.request)} *)DataDuplicate);
    %endif
    ErrorValue = memcmp(DataDuplicate, Input->Data, sizeof(${get_struct_type(cmd.request)}));
    break;

  %endfor
    /*
     * Accessors like S*** must be below.
     */
  %for cmd in view.setter_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    memcpy(DataDuplicate, Input->Data, sizeof(${get_struct_type(cmd.request)}));
    on_${namespaced(cmd.name)}((${get_struct_type(cmd.request)} *)DataDuplicate);
    ErrorValue = memcmp(DataDuplicate, Input->Data, sizeof(${get_struct_type(cmd.request)}));
    ATOMIC_RUN(memcpy(&Commands_SettingsStorage.${get_struct_code_ac(cmd)}, DataDuplicate, sizeof(${get_struct_type(cmd.request)})));
    break;

  %endfor
    /*
     * Regular commands without input data must be below.
     */
  %for cmd in view.noinput_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    %if len(cmd.response.args) != 0:
    on_${namespaced(cmd.name)}((${get_struct_type(cmd.response)} *)Output->Data);
    %else:
    on_${namespaced(cmd.name)}();
    %endif
    break;

  %endfor
    /*
     * Accessors like G*** must be below.
     */
  %for cmd in view.getter_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    ATOMIC_RUN(memcpy(Output->Data, &Commands_SettingsStorage.${get_struct_code_ac(cmd)}, sizeof(${get_struct_type(cmd.response)})));
    break;

  %endfor
#ifdef DEBUG
  default:  // Detect generation error
    while (1)
    {
      // Capture
    }
#endif  // DEBUG
  }

  /*
   * Check ERRV state.
   */
  if (ErrorValue)
  {
    Output->Command = ERRV_CMD;
    Output->Size    = _COMMAND_LENGTH;
    return;
  }

  if (Output->Size > _COMMAND_LENGTH)   // If data was added
  {
#ifdef DEBUG
    if (Output->Size <= _COMMAND_LENGTH + _CRC_LENGTH)  // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint8_t   CheckCode[_CRC_LENGTH];
    uint16_t  OutputFieldsSize = Output->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes at the end of packet (after output fields).
     *
     * Cortex-M0+ doesn't support unaligned memory access. We must copy
     * the CRC16 bytes by byte.
     *
     * See:
     *   - http://infocenter.arm.com/help/topic/com.arm.doc.dui0662b/BABFAIGG.html
     *   - http://infocenter.arm.com/help/topic/com.arm.doc.dui0552a/BABFAIGG.html
     */
    *(uint16_t *)CheckCode = Algorithm_CRC16(Output->Data, OutputFieldsSize, ALGORITHM_CRC16_SEED);

    for (uint32_t Index = 0; Index < _CRC_LENGTH; Index++)
    {
      *(uint8_t *)(Output->Data + OutputFieldsSize + Index) = CheckCode[Index];
    }
  }
}

/*
 * This function handles protocol parsing and protocol response between controlling unit and the device
 * A fully received command is searched for in incoming cycle buffer. Whence found, it is processed with GetData()
 * the return value describes whether a command has been processed
 * It also handles synchronization zeroes logic.
 */
uint16_t FlowParser_Process(io_buffer_t *pRxBuf, io_buffer_t *pTxBuf)
{
  static packet_t ReadPacket;   // Packet under examination

  packet_t WritePacket;         // Packet to store the response
  uint16_t retval = 0;          // Return value (number of new bytes to send)

  // First we look whether we have previous knowledge about command length
  if (ReadPacket.Size == 0) // Length is zero - check for command
  {
    /*
     * If first symbol is '\0' then we must echo
     * and discard it (the same for each next byte)
     */
    while (IOBuffer_Size(pRxBuf))   // While there are symbols in the input buffer
    {
      uint8_t FirstByte;

      IOBuffer_PeekC(pRxBuf, &FirstByte);   // Look at first byte

      /*
       * If byte is a command byte - exit cycle
       * and proceed to command recognition
       */
      if (FirstByte)
      {
        break;  // Quit the cycle
      }

      /*
       * Otherwise load zero byte from buffer
       * and prepare to send it
       */
      IOBuffer_GetC(pRxBuf, &FirstByte);
      IOBuffer_PutC(pTxBuf, FirstByte);

      retval++;   // One more byte to send
    }

    /*
     * Now first byte is not zero
     * and must be the first symbol of a command
     */
    if (IOBuffer_Size(pRxBuf) < _COMMAND_LENGTH)  // Command not received yet
      return retval;  // Return and wait for missing bytes

    /*
     * We have a command.
     * Proceed...
     */
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Array, _COMMAND_LENGTH);   // Transfer bytes from cycle buffer to packet structure
    ReadPacket.Size = Commands_GetInputSize(ReadPacket.Command);  // Get additional data size
  }

  /*
   * At this stage we know our command and its size
   */
  if (ReadPacket.Size)  // If there is any additional data to receive. (Not else)
  {
    uint16_t DataSize = ReadPacket.Size - _COMMAND_LENGTH;

    if (IOBuffer_Size(pRxBuf) < DataSize)   // If not enough additional data
      return retval;  // Quit and wait for more data

#ifdef DEBUG
    if (IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize) != true)   // Detect generation error
      while (1)
      {
        // Capture
      }
#else
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize);   // Transfer data to packet structure.
#endif  // DEBUG
  }

  /*
   * At this stage we have a packet with command
   * with possible additional data. Beginning processing.
   */
  ParsePacketPreparePacket(&ReadPacket, &WritePacket);  // Process command

  IOBuffer_PutBuf(pTxBuf, WritePacket.Array, WritePacket.Size);   // Copy response to output buffer

  ReadPacket.Size = 0;  // Reinit command sequence

  return retval + WritePacket.Size;
}

#if defined(__cplusplus)
};
#endif
