<%namespace file="handlers.h.mako" import="get_struct_type"></%namespace>\
<%namespace file="handlers.h.mako" import="get_struct_code_ac"></%namespace>\
<%namespace file="handlers.h.mako" import="get_struct_code"></%namespace>\
<%namespace import="namespaced" module = "urpc.builder.device.utils.namespaced" inheritable="True"/>\
/*
 * Each file must start with this include.
 * File containes global settings.
 */
#include "settings.h"

/*
 * Main includes here.
 */
#include "flowparser.h"

/*
 * This file is autogenerated.
 * Changes made to this file can be overwritten.
 */

/*
 * Other includes here.
 */
#include <string.h>     // Required for memcpy()
#include "atomicrun.h"
#include "commands.h"   // Protocol definitions
#include "handlers.h"
#include "macro.h"
#include "algorithm.h"  // Required for CRC16

#if defined(__cplusplus)
extern "C"
{
#endif

typedef struct
{
  union
  {
    uint8_t Array[_PACKET_LENGTH];
    struct
    {
      uint32_t  Command;
      uint8_t   Data[_PACKET_LENGTH - _COMMAND_LENGTH];
    };
  };
  uint16_t Size;

} packet_t;

static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output);

/*
 * This function gets a command-packet structure
 * and puts into response command-packet.
 * The Array size must be enough to hold any single response.
 */
static void ParsePacketPreparePacket(const packet_t *Input, packet_t *Output)
{
  uint16_t crc;   // This value will contain the packet CRC16 code to verify its data

  /*
   * Each transmit starts with command code. Just copy...
   * After that find packet size in table and paste to the structure.
   */
  Output->Command = Input->Command;
  Output->Size = Commands_GetOutputSize(Output->Command);

  /*
   * Check ERRC state. Checking is based on the return
   * value of the function Commands_GetOutputSize(...).
   * See description Commands_GetOutputSize(...) for more information.
   */
  if (Output->Size == 0)
  {
    Output->Command = ERRC_CMD;
    Output->Size = _COMMAND_LENGTH;
    return;
  }

  /*
   * Check ERRD state.
   */
  if (Input->Size > _COMMAND_LENGTH)  // If there is some data
  {
#ifdef DEBUG
    if (Input->Size <= _COMMAND_LENGTH + _CRC_LENGTH)   // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint16_t InputFieldsSize = Input->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes from the end of packet (after input fields).
     */
    crc = HWREGH(Input->Data + InputFieldsSize);

    /*
     * Calc and check CRC16.
     */
    if (crc != Algorithm_CRC16(Input->Data, InputFieldsSize, ALGORITHM_CRC16_SEED))
    {
      Output->Command = ERRD_CMD;
      Output->Size = _COMMAND_LENGTH;
      return;
    }
  }

  /*
   * If in the end errv is non zero, it means that a value
   * came out of the range and has been corrected.
   */
  int32_t errv = 0;



  switch (Input->Command)
  {
    /*
     * Regular commands with input data must be below
     */
  %for cmd in view.regular_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    {
      ${get_struct_type(cmd.request)} original;
      ${get_struct_type(cmd.request)} duplicate;
    %if len(cmd.response.args)!=0:
      ${get_struct_type(cmd.response)} output;
    %endif

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

    %if len(cmd.response.args)!=0:
      on_${namespaced(cmd.name)}(&duplicate, &output);
    %else:
      on_${namespaced(cmd.name)}(&duplicate);
    %endif

      errv |= memcmp(&original, &duplicate, sizeof(original));
    %if len(cmd.response.args)!=0:

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    %endif
    }
    break;

  %endfor
    /*
     * Accessors like S*** must be below
     */
  %for cmd in view.setter_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    {
      ${get_struct_type(cmd.request)} original;
      ${get_struct_type(cmd.request)} duplicate;

      memcpy(&original, Input->Data, sizeof(original));
      memcpy(&duplicate, Input->Data, sizeof(duplicate));

      on_${namespaced(cmd.name)}(&duplicate);

      errv |= memcmp(&original, &duplicate, sizeof(original));

      ATOMIC_RUN(memcpy(&Commands_SettingsStorage.${get_struct_code_ac(cmd)}, &duplicate, sizeof(duplicate)));
    }
    break;

  %endfor
    /*
     * Regular commands without input data must be below.
     */
  %for cmd in view.noinput_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    {
    %if len(cmd.response.args)!=0:
      ${get_struct_type(cmd.response)} output;
      on_${namespaced(cmd.name)}(&output);

      ATOMIC_RUN(memcpy(Output->Data, &output, sizeof(output)));
    %else:
      on_${namespaced(cmd.name)}();
    %endif
    }
    break;

  %endfor
    /*
     * Accessors like G*** must be below
     */
  %for cmd in view.getter_handlers_commands:
  case ${namespaced(view._command_code(cmd.cid))}:
    {
      ATOMIC_RUN(memcpy(Output->Data, &Commands_SettingsStorage.${get_struct_code_ac(cmd)}, sizeof(Commands_SettingsStorage.${get_struct_code_ac(cmd)})));
    }
    break;
  %endfor

#ifdef DEBUG
  default:  // Detect generation error
    while (1)
    {
      // Capture
    }
#endif  // DEBUG
  }

  /*
   * Check ERRV state.
   */
  if (errv)
  {
    Output->Command = ERRV_CMD;
    Output->Size = _COMMAND_LENGTH;
    return;
  }

  if (Output->Size > _COMMAND_LENGTH)   // If data was added
  {
#ifdef DEBUG
    if (Output->Size <= _COMMAND_LENGTH + _CRC_LENGTH)  // Detect generation error
    {
      while (1)
      {
        // Capture
      }
    }
#endif  // DEBUG

    uint16_t OutputFieldsSize = Output->Size - _COMMAND_LENGTH - _CRC_LENGTH;

    /*
     * Using as CRC16 2 bytes at the end of packet (after output fields).
     * Calculate CRC16 and paste.
     */
    HWREGH(Output->Data + OutputFieldsSize) = Algorithm_CRC16(Output->Data, OutputFieldsSize, ALGORITHM_CRC16_SEED);
  }

  return;
}

/*
 * This function handles protocol parsing and protocol response between controlling unit and the device
 * A fully received command is searched for in incoming cycle buffer. Whence found, it is processed with GetData()
 * the return value describes whether a command has been processed
 * It also handles synchronization zeroes logic.
 */
uint16_t FlowParser_Process(io_buffer_t *pRxBuf, io_buffer_t *pTxBuf)
{
  static packet_t ReadPacket;   // Packet under examination

  packet_t WritePacket;         // Packet to store the response
  uint16_t retval = 0;          // Return value (number of new bytes to send)

  // First we look whether we have previous knowledge about command length
  if (ReadPacket.Size == 0) // Length is zero - check for command
  {
    /*
     * If first symbol is '\0' then we must echo
     * and discard it (the same for each next byte)
     */
    while (IOBuffer_Size(pRxBuf))   // While there are symbols in the input buffer
    {
      uint8_t FirstByte;

      IOBuffer_PeekC(pRxBuf, &FirstByte);   // Look at first byte

      /*
       * If byte is a command byte - exit cycle
       * and proceed to command recognition
       */
      if (FirstByte)
      {
        break;  // Quit the cycle
      }

      /*
       * Otherwise load zero byte from buffer
       * and prepare to send it
       */
      IOBuffer_GetC(pRxBuf, &FirstByte);
      IOBuffer_PutC(pTxBuf, FirstByte);

      retval++;   // One more byte to send
    }

    /*
     * Now first byte is not zero
     * and must be the first symbol of a command
     */
    if (IOBuffer_Size(pRxBuf) < _COMMAND_LENGTH)  // Command not received yet
      return retval;  // Return and wait for missing bytes

    /*
     * We have a command.
     * Proceed...
     */
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Array, _COMMAND_LENGTH);   // Transfer bytes from cycle buffer to packet structure
    ReadPacket.Size = Commands_GetInputSize(ReadPacket.Command);  // Get additional data size
  }

  /*
   * At this stage we know our command and its size
   */
  if (ReadPacket.Size)  // If there is any additional data to receive. (Not else)
  {
    uint16_t DataSize = ReadPacket.Size - _COMMAND_LENGTH;

    if (IOBuffer_Size(pRxBuf) < DataSize)   // If not enough additional data
      return retval;  // Quit and wait for more data

#ifdef DEBUG
    if (IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize) != true)   // Detect generation error
      while (1)
      {
        // Capture
      }
#else
    IOBuffer_GetBuf(pRxBuf, ReadPacket.Data, DataSize);   // Transfer data to packet structure.
#endif  // DEBUG
  }

  /*
   * At this stage we have a packet with command
   * with possible additional data. Beginning processing.
   */
  ParsePacketPreparePacket(&ReadPacket, &WritePacket);  // Process command

  IOBuffer_PutBuf(pTxBuf, WritePacket.Array, WritePacket.Size);   // Copy response to output buffer

  ReadPacket.Size = 0;  // Reinit command sequence

  return retval + WritePacket.Size;
}

#if defined(__cplusplus)
};
#endif
