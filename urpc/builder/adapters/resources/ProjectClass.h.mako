//=============================================================================
//
// file :        ${device_name(protocol)}Class.h
//
// description : Include for the ${device_name(protocol)} root class.
//               This class is the singleton class for
//                the ${device_name(protocol)} device class.
//               It contains all properties and methods which the
//               ${device_name(protocol)} requires only once e.g. the commands.
//
// project :     StandaTango
//
// This file is part of Tango device class.
//
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
//
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#ifndef ${device_name(protocol)}Class_H
#define ${device_name(protocol)}Class_H

#include <tango.h>
#include "${device_name(protocol)}.h"


namespace ${device_name(protocol)}_ns {


/**
 *	The ${device_name(protocol)}Class singleton definition
 */

#ifdef _TG_WINDOWS_
class __declspec(dllexport) ${device_name(protocol)}Class : public Tango::DeviceClass
#else
class ${device_name(protocol)}Class : public Tango::DeviceClass
#endif
{
public:
    Tango::DbData	cl_prop;
    Tango::DbData	cl_def_prop;
    Tango::DbData	dev_def_prop;

    static ${device_name(protocol)}Class *init(const char *);
    static ${device_name(protocol)}Class *instance();
    ~${device_name(protocol)}Class();
    Tango::DbDatum	get_class_property(string &);
    Tango::DbDatum	get_default_device_property(string &);
    Tango::DbDatum	get_default_class_property(string &);

protected:
    ${device_name(protocol)}Class(string &);
    static ${device_name(protocol)}Class *_instance;
    void command_factory();
    void attribute_factory(vector<Tango::Attr *> &);
    void write_class_property();
    void set_default_property();
    void get_class_property();
    string get_cvstag();
    string get_cvsroot();

private:
    void device_factory(const Tango::DevVarStringArray *);
    void create_static_attribute_list(vector<Tango::Attr *> &);
    void erase_dynamic_attributes(const Tango::DevVarStringArray *,vector<Tango::Attr *> &);
    vector<string> defaultAttList;
    Tango::Attr *get_attr_object_by_name(vector<Tango::Attr *> &att_list, string attname);
};	// class ${device_name(protocol)}Class


<%namespace file="${context['import_file']('Project.h.mako')}" import="command_handler_name, attribute_handler_base_name, reader_handler_name, writer_handler_name, validator_name"/>\
<%!
    from itertools import chain
    from urpc import ast


    def _get_tango_type_code(type):
        type = type.type_ if isinstance(type, ast.ArrayType) else type

        if type in (ast.Integer8s, ast.Integer8u):
            return "DEV_UCHAR"
        elif type == ast.Integer16u:
            return "DEV_USHORT"
        elif type == ast.Integer16s:
            return "DEV_SHORT"
        elif type == ast.Integer32u:
            return "DEV_ULONG"
        elif type == ast.Integer32s:
            return "DEV_LONG"
        elif type == ast.Integer64u:
            return "DEV_ULONG64"
        elif type == ast.Integer64s:
            return "DEV_LONG64"
        elif type == ast.Float:
            return "DEV_FLOAT"
        else:
            return "DEV_VOID"
%>\
<%def name="type_code(arg)">Tango::${_get_tango_type_code(arg.type_)}</%def>\
<%def name="attribute_class_name(arg)">${attribute_handler_base_name(arg)}AttrClass</%def>\
<%def name="attribute_rw_modifier(arg)"><%
    msg = arg.parent
    cmd = msg.parent
    rw_modifier = "READ_WRITE"
    if not is_accessor_part(cmd):
        if is_request(msg):
            rw_modifier = "WRITE"
        elif is_response(msg):
            rw_modifier = "READ"
        else:
            assert False
%>Tango::${rw_modifier}</%def>\
<%def name="attribute_class_definition(arg)"><%
    is_array = isinstance(arg.type_, ast.ArrayType)
    base_class = "SpectrumAttr" if is_array else "Attr"
%>\
class ${attribute_class_name(arg)}: public Tango::${base_class} {
public:
    ${attribute_class_name(arg)}() : Tango::${base_class}(
        "${attribute_handler_base_name(arg)}",
        ${type_code(arg)},
        ${attribute_rw_modifier(arg)}\
    % if is_array:
,
        ${len(arg.type_)}
    % else:

    % endif
    )
    {}

    % if is_response(arg.parent) or is_accessor_part(arg.parent.parent):
    virtual void read(Tango::DeviceImpl *dev, Tango::Attribute &att) {
        (static_cast<${device_name(protocol)} *>(dev))->${reader_handler_name(arg)}(att);
    }
    % endif
    % if is_request(arg.parent) or is_accessor_part(arg.parent.parent):
    virtual void write(Tango::DeviceImpl *dev,Tango::WAttribute &att) {
        (static_cast<${device_name(protocol)} *>(dev))->${writer_handler_name(arg)}(att);
    }
    % endif

    virtual bool is_allowed(Tango::DeviceImpl *dev,Tango::AttReqType ty) {
        return (static_cast<${device_name(protocol)} *>(dev))->${validator_name(arg)}(ty);
    }
};
</%def>\

<%def name="command_class_name(cmd)">${command_handler_name(cmd)}CmdClass</%def>\
<%def name="command_class_def(cmd)">\
class ${command_class_name(cmd)} : public Tango::Command {
public:
    ${command_class_name(cmd)}(
        const char* name,
        Tango::CmdArgType in,
        Tango::CmdArgType out,
        const char* in_desc,
        const char* out_desc,
        Tango::DispLevel level
    ) : Command(name, in, out, in_desc, out_desc, level)
    {}

    ${command_class_name(cmd)}(
        const char* name,
        Tango::CmdArgType in,
        Tango::CmdArgType out
    ) : Command(name, in, out)
    {}

    virtual CORBA::Any *execute(Tango::DeviceImpl *device, const CORBA::Any &) {
        cout2 << "${command_class_name(cmd)}::execute(): arrived" << std::endl;
        ((static_cast<${device_name(protocol)} *>(device))->${command_handler_name(cmd)}());
        return new CORBA::Any();
    }

    virtual bool is_allowed (Tango::DeviceImpl *dev, const CORBA::Any &any) {
        return (static_cast<${device_name(protocol)} *>(dev))->is_${command_handler_name(cmd)}_allowed(any);
    }
};	// class ${command_class_name(cmd)}
</%def>\
% for cmd in all_cmds(protocol):
${command_class_def(cmd)}\
    % for arg in chain(external_args(cmd.request), external_args(cmd.response)):
${attribute_class_definition(arg)}
    % endfor
% endfor
% for (getter, setter) in all_accs(protocol):
    % for arg in getter.response.args:
${attribute_class_definition(arg)}
    % endfor
% endfor


}	// namespace ${device_name(protocol)}_ns

#endif   //	${device_name(protocol)}_H
