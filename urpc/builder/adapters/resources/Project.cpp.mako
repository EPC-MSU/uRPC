<%namespace import="namespaced" module = "urpc.builder.device.utils.namespaced" inheritable="True"/>
<%namespace file="${context['import_file']('Project.h.mako')}" import="command_handler_decl, command_handler_name, reader_handler_decl, reader_handler_name, writer_handler_decl, writer_handler_name, buffer_name, buffer_mutex_name, buffer_measure_time_name, buffer_measure_time_got_name, poller_name, poller_thread_name"/>\
<%!
    from urpc import ast
%>
\
<%def name="buffer_member_var(arg)">${buffer_name(arg.parent)}.${arg.name}</%def>\
<%def name="buffer_member_lock_vars_def(arg_or_cmd)">\
% if isinstance(arg_or_cmd, ast.Argument):
    % if has_ext_args(arg_or_cmd.parent):
std::lock_guard<std::mutex> out_lock(${buffer_mutex_name(arg_or_cmd.parent)});\
    % endif
% elif has_ext_args(arg_or_cmd.request) and has_ext_args(arg_or_cmd.response):
std::lock(${buffer_mutex_name(arg_or_cmd.request)}, ${buffer_mutex_name(arg_or_cmd.response)}); std::lock_guard<std::mutex> in_lock(${buffer_mutex_name(arg_or_cmd.request)}, std::adopt_lock), out_lock(${buffer_mutex_name(arg_or_cmd.response)}, std::adopt_lock);\
% elif has_ext_args(arg_or_cmd.request):
std::lock_guard<std::mutex> in_lock(${buffer_mutex_name(arg_or_cmd.request)});\
% elif has_ext_args(arg_or_cmd.response):
std::lock_guard<std::mutex> out_lock(${buffer_mutex_name(arg_or_cmd.response)});\
% else:
// Command ${arg_or_cmd.name} has no buffer\
% endif
</%def>\
\
<%def name="func_call(cmd)">\
handle_result(::${namespaced(cmd.name)}(device\
% if is_accessor_part(cmd):
, &${buffer_name(cmd.response if len(cmd.response.args) else cmd.request)}\
% else:
    % if has_ext_args(cmd.request):
, &${buffer_name(cmd.request)}\
    % endif
    % if has_ext_args(cmd.response):
, &${buffer_name(cmd.response)}\
    % endif
% endif
), "${cmd.name}")\
</%def>\
\
//=============================================================================
//
// file :        ${device_name(protocol)}.cpp
//
// description : C++ source for the ${device_name(protocol)} class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               ${device_name(protocol)} are implemented in this file.
//
// project :     StandaTango
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <algorithm>
#include <cstring>

#include <tango.h>

#include "${device_name(protocol)}.h"
#include "${device_name(protocol)}Class.h"
#include "${device_name(protocol)}Config.h"


static_assert(
    sizeof(int32_t) == sizeof(Tango::DevLong) && alignof(int32_t) == alignof(Tango::DevLong) &&
    sizeof(uint32_t) == sizeof(Tango::DevULong) && alignof(uint32_t) == alignof(Tango::DevULong),
    "Current version works only on platforms where (u)int32_t is the same as Tango::Dev(U)Long"
);


/**
 *  ${device_name(protocol)} class description:
 *    Tango device server implementation for Standa 8smc4usb motion control device.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//================================================================

namespace ${device_name(protocol)}_ns {


${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, std::string &s)
    : TANGO_BASE_CLASS(cl, s.c_str())
% if protocol_has_reactive_attrs(protocol):
    , pollers_need_continue(false)
% else:
    // ${device_name(protocol)} has no pollers, so this field will be unused
    // , pollers_need_continue(false)
% endif
{
	init_device();
}

${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, const char *s)
    : TANGO_BASE_CLASS(cl, s)
% if protocol_has_reactive_attrs(protocol):
    , pollers_need_continue(false)
% else:
    // ${device_name(protocol)} has no pollers, so this field will be unused
    // , pollers_need_continue(false)
% endif
{
	init_device();
}

${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, const char *s, const char *d)
    : TANGO_BASE_CLASS(cl, s, d)
% if protocol_has_reactive_attrs(protocol):
    , pollers_need_continue(false)
% else:
    // ${device_name(protocol)} has no pollers, so this field will be unused
    // , pollers_need_continue(false)
% endif
{
	init_device();
}

/**
 *	Method      : ${device_name(protocol)}::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void ${device_name(protocol)}::delete_device()
{
    const steady_time_point t = steady_now();

	// Delete device allocated objects
    set_state(Tango::CLOSE);
    set_status("Deinitializing");

    stop_pollers();
    deinit_hardware();

    set_state(Tango::OFF);
    set_status("");

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": delete_device done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

//--------------------------------------------------------
/**
 *	Method      : ${device_name(protocol)}::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void ${device_name(protocol)}::init_device()
{
    const steady_time_point t = steady_now();

    // Zero-initialize all buffers to prevent garbage reads
% for cmd in all_cmds(protocol):
    % if needs_external_buffer(cmd.request):
    std::memset(&${buffer_name(cmd.request)}, 0, sizeof(${buffer_name(cmd.request)}));
    % endif
    % if needs_external_buffer(cmd.response):
    std::memset(&${buffer_name(cmd.response)}, 0, sizeof(${buffer_name(cmd.response)}));
    % endif
% endfor

% if len(tuple(all_accs(protocol))) > 0 or any(needs_external_buffer(cmd.response) for cmd in all_cmds(protocol)) > 0:
    // Initialize all timestamps
    struct timeval timestamp;
    bool timestamp_got = false;
    if (gettimeofday(&timestamp, nullptr) == 0) {
        timestamp_got = true;

    % for cmd in all_cmds(protocol):
        % if needs_external_buffer(cmd.response):
        ${buffer_measure_time_name(cmd.response)} = timestamp;
        % endif
    % endfor
    % for (getter, setter) in all_accs(protocol):
        ${buffer_measure_time_name(getter.request)} = timestamp;
    % endfor
    }

    % for cmd in all_cmds(protocol):
        % if needs_external_buffer(cmd.response):
        ${buffer_measure_time_got_name(cmd.response)} = timestamp_got;
        % endif
    % endfor
    % for (getter, setter) in all_accs(protocol):
        ${buffer_measure_time_got_name(getter.request)} = timestamp_got;
    % endfor
% endif

    {
        std::lock_guard<std::mutex> device_lock(device_mutex);

        // Get the device properties from database
        get_device_property();

        init_hardware();
        start_pollers();
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": init_device done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

//--------------------------------------------------------
/**
 *	Method      : ${device_name(protocol)}::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void ${device_name(protocol)}::get_device_property()
{
    const steady_time_point t = steady_now();

    // Initialize property data members

    // Read device properties from database.
    Tango::DbData dev_prop;
    dev_prop.push_back(Tango::DbDatum("DevicePath"));

    // is there at least one property to be read?
    if (dev_prop.size() > 0) {
        // Call database and extract values
        if (Tango::Util::instance()->_UseDb) {
            get_db_device()->get_property(dev_prop);
        }

        // get instance on ${device_name(protocol)}Class to get class property
        Tango::DbDatum def_prop, cl_prop;
        ${device_name(protocol)}Class *ds_class = static_cast<${device_name(protocol)}Class *>(get_device_class());
        int	i = -1;

        // Try to initialize DevicePath from class property
        cl_prop = ds_class->get_class_property(dev_prop[++i].name);
        if (!cl_prop.is_empty()) {
            cl_prop >> device_path;
        } else {
            //	Try to initialize DevicePath from default device value
            def_prop = ds_class->get_default_device_property(dev_prop[i].name);
            if (!def_prop.is_empty()) {
                def_prop >> device_path;
            }
        }
        //	And try to extract DevicePath value from database
        if (!dev_prop[i].is_empty()) {
            dev_prop[i] >> device_path;
        }
    }

    //	Check device property data members init

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": get_device_property done in " << steady_time_diff(t) << " s." << std::endl;
    }
}


void ${device_name(protocol)}::start_pollers()
{
    const steady_time_point t = steady_now();

    if (!${device_name(protocol)}_internal_ns::${device_name(protocol)}_reactive_enabled) {
        if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_pollers) {
            DEBUG_STREAM << device_path << ": start_pollers done (nothing to start) in " << steady_time_diff(t) << " s." << std::endl;
        }
        return;
    }

% if protocol_has_reactive_attrs(protocol):
    // Say pollers to run
    pollers_need_continue.store(true);

<%def name="start_poller(cmd)">\
    ${poller_thread_name(cmd)} = std::thread(&${device_name(protocol)}::${poller_name(cmd)}, this);
</%def>\
    % for cmd in all_cmds(protocol):
        % if cmd_has_reactive_attrs(cmd):
${start_poller(cmd)}
        % endif
    % endfor
    % for (getter, setter) in all_accs(protocol):
        % if cmd_has_reactive_attrs(getter):
${start_poller(getter)}
        % endif
    % endfor
% else:
    // ${device_name(protocol)} has no pollers
% endif

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_pollers) {
        DEBUG_STREAM << device_path << ": start_pollers done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

void ${device_name(protocol)}::stop_pollers()
{
    const steady_time_point t = steady_now();

    if (!${device_name(protocol)}_internal_ns::${device_name(protocol)}_reactive_enabled) {
        if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_pollers) {
            DEBUG_STREAM << device_path << ": stop_pollers done (nothing to stop) in " << steady_time_diff(t) << " s." << std::endl;
        }
        return;
    }

% if protocol_has_reactive_attrs(protocol):
    // Say pollers to stop
    pollers_need_continue.store(false);

<%def name="join_poller(cmd)">\
    // Stop ${poller_name(cmd)}
    if (${poller_thread_name(cmd)}.joinable()) {
        try {
            ${poller_thread_name(cmd)}.join();
        } catch (const std::exception &e) {
            ERROR_STREAM << device_path << ": stop_pollers: ${poller_name(cmd)}: Exception caught: " << e.what() << '.' << std::endl;
        }
    }
</%def>\
    % for cmd in all_cmds(protocol):
        % if cmd_has_reactive_attrs(cmd):
${join_poller(cmd)}\
        % endif
    % endfor
    % for (getter, setter) in all_accs(protocol):
        % if cmd_has_reactive_attrs(getter):
${join_poller(getter)}\
        % endif
    % endfor
% else:
    // ${device_name(protocol)} has no pollers
% endif

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_pollers) {
        DEBUG_STREAM << device_path << ": stop_pollers done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

## Describe protocol commands in TANGO terms(tango commands, read- and write-only attributes)
// Protocol commands
% for cmd in all_cmds(protocol):
## TANGO command handler declaration for protocol command
${command_handler_decl(cmd)}
{
    // Command handler
    const steady_time_point t = steady_now();

    {
        std::lock_guard<std::mutex> device_lock(device_mutex);
        if (device_state == DeviceState::DEVICE_OK || try_reinit_hardware()) {
            ${buffer_member_lock_vars_def(cmd)}
    % if needs_external_buffer(cmd.response):
            if (${func_call(cmd)}) {
                get_time(
                    ${buffer_measure_time_name(cmd.response)},
                    ${buffer_measure_time_got_name(cmd.response)}
                );
            }
    % else:
            ${func_call(cmd)};
    % endif
        }
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": ${command_handler_name(cmd)} done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

## TANGO write-only attribute handler declarations for commands' input arguments
<%
    out_args = list(external_args(cmd.request))
    reserved_out_args, non_reserved_out_args = set(), set()
    for arg in out_args:
        if arg.name.lower().find("reserved") == -1:
            non_reserved_out_args.add(arg)
        else:
            reserved_out_args.add(arg)
%>\
    % for arg in out_args:
        % if attr_is_reactive(arg) and len(non_reserved_out_args) <= 1:
${writer_handler_decl(arg)}
{
    // Write-only attribute handler for reactive attribute (and another fields are reserved => will be zero'ed)
    const steady_time_point t = steady_now();

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_reactive_enabled) {
        {
            std::lock_guard<std::mutex> device_lock(device_mutex);
            if (device_state == DeviceState::DEVICE_OK || try_reinit_hardware()) {
                // Write handler
                ${buffer_member_lock_vars_def(arg)}
                // Write to buffer
            % if isinstance(arg.type_, ast.ArrayType):
                const Tango::${tango_type(arg.type_)} w_val;
                attr.get_write_value(w_val);
                std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type_.size});
            % else:
                Tango::${tango_type(arg.type_)} w_val;
                attr.get_write_value(w_val);
                ${buffer_member_var(arg)} = w_val;
            % endif

                // Warning: Heuristic: fill with zeros (another) reserved fields and call setter,
                // if has <= 1 non-reserved fields
            % for another_reserved_arg in reserved_out_args - {arg}:
                % if isinstance(another_reserved_arg.type, ast.ArrayType):
                std::memset(&${buffer_member_var(another_reserved_arg)}, 0, ${another_reserved_arg.type.size});
                % else:
                ${buffer_member_var(another_reserved_arg)} = 0;
                % endif
            % endfor

                ${func_call(cmd)};
            }
        }

        if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_aw) {
            DEBUG_STREAM << device_path << ": ${writer_handler_name(arg)} done in " << steady_time_diff(t) << " s." << std::endl;
        }
    } else {
        {
            // Write handler
            ${buffer_member_lock_vars_def(arg)}
            // Write to buffer
            % if isinstance(arg.type_, ast.ArrayType):
            const Tango::${tango_type(arg.type_)} w_val;
            attr.get_write_value(w_val);
            std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type_.size});
            % else:
            Tango::${tango_type(arg.type_)} w_val;
            attr.get_write_value(w_val);
            ${buffer_member_var(arg)} = w_val;
            % endif
        }

        if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_aw) {
            DEBUG_STREAM << device_path << ": ${writer_handler_name(arg)} (non-reactive mode) done in " << steady_time_diff(t) << " s." << std::endl;
        }
    }
}
        % else:
${writer_handler_decl(arg)}
{
    // Write-only attribute handler
    const steady_time_point t = steady_now();

    {
        // Write handler
        ${buffer_member_lock_vars_def(arg)}
        // Write to buffer
            % if isinstance(arg.type_, ast.ArrayType):
        const Tango::${tango_type(arg.type_)} w_val;
        attr.get_write_value(w_val);
        std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type_.size});
            % else:
        Tango::${tango_type(arg.type_)} w_val;
        attr.get_write_value(w_val);
        ${buffer_member_var(arg)} = w_val;
            % endif
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_aw) {
        DEBUG_STREAM << device_path << ": ${writer_handler_name(arg)} done in " << steady_time_diff(t) << " s." << std::endl;
    }
}
        % endif

    % endfor
\
## TANGO read-only attribute handler declarations for commands' output arguments
    % for arg in external_args(cmd.response):
${reader_handler_decl(arg)}
{
    // Read-only attribute handler
    const steady_time_point t = steady_now();

    {
        // Read handler
        ${buffer_member_lock_vars_def(arg)}
        // Read from buffer
        % if isinstance(arg.type_, ast.ArrayType):
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)}>(${buffer_member_var(arg)}), ${len(arg.type_)});
        % else:
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)} *>(&${buffer_member_var(arg)}));
        % endif
        if (${buffer_measure_time_got_name(cmd.response)}) {
            attr.set_date(${buffer_measure_time_name(cmd.response)});
        }
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_ar) {
        DEBUG_STREAM << device_path << ": ${reader_handler_name(arg)} done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

    % endfor
% endfor
\
## Describe protocol accessors in TANGO terms(tango read-write attributes)
// Protocol accessors
% for (getter, setter) in all_accs(protocol):
    % for arg in getter.response.args:
## Write handler definition
${writer_handler_decl(arg)}
{
    // Writer for accessor argument
    const steady_time_point t = steady_now();

    {
        std::lock_guard<std::mutex> device_lock(device_mutex);
        if (device_state == DeviceState::DEVICE_OK || try_reinit_hardware()) {
            // Write handler
            ${buffer_member_lock_vars_def(arg)}
            if (${func_call(getter)}) {
                get_time(
                    ${buffer_measure_time_name(getter.response)},
                    ${buffer_measure_time_got_name(getter.response)}
                );
            }
            // Write to buffer
        % if isinstance(arg.type_, ast.ArrayType):
            const Tango::${tango_type(arg.type_)} w_val;
            attr.get_write_value(w_val);
            std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type_.size});
        % else:
            Tango::${tango_type(arg.type_)} w_val;
            attr.get_write_value(w_val);
            ${buffer_member_var(arg)} = w_val;
        % endif
            ${func_call(setter)};
        }
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_aw) {
        DEBUG_STREAM << device_path << ": ${writer_handler_name(arg)} done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

## Read handler definition
${reader_handler_decl(arg)}
{
    // Reader for accessor argument
    const steady_time_point t = steady_now();
    bool cmd_executed_ok = false;

    {
        std::unique_lock<std::mutex> device_lock(device_mutex);
        ${buffer_member_lock_vars_def(arg)}
        // Read handler
        if (
            device_state == DeviceState::DEVICE_OK
            || (
                ${device_name(protocol)}_internal_ns::${device_name(protocol)}_reinit_by_readers_enabled
                && try_reinit_hardware()
            )
        ) {
            cmd_executed_ok = ${func_call(getter)};
        }
        device_lock.unlock();

        if (cmd_executed_ok) {
            get_time(
                ${buffer_measure_time_name(getter.request)},
                ${buffer_measure_time_got_name(getter.request)}
            );
        }

        // Read from buffer
        % if isinstance(arg.type_, ast.ArrayType):
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)}>(${buffer_member_var(arg)}), ${len(arg.type_)});
        % else:
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)} *>(&${buffer_member_var(arg)}));
        % endif
        if (${buffer_measure_time_got_name(getter.request)}) {
            attr.set_date(${buffer_measure_time_name(getter.request)});
        }
    }

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_ar) {
        DEBUG_STREAM << device_path << ": ${reader_handler_name(arg)} done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

    % endfor
% endfor
\
bool ${device_name(protocol)}::get_time(struct timeval &t, bool &got)
{
    // Non-const method because of Tango logging!

    bool res = true;
    if (gettimeofday(&t, nullptr) != 0) {
        res = false;
        int current_errno = errno;
        WARN_STREAM << "Can not get timestamp: " << strerror(current_errno) << "... " << device_name << ", " << device_path << std::endl;
    }
    got = res;
    return res;
}


// High-level
bool ${device_name(protocol)}::init_hardware()
{
    const steady_time_point t = steady_now();

    set_state(Tango::INIT);
    set_status("Initializing");
    device_state = DeviceState::DEVICE_NOT_OPENED;

    last_device_open_try_time = t;

    device = ::${namespaced("open_device")}(device_path.c_str());
    if (device == device_undefined) {
        set_state(Tango::FAULT);
        set_status("Failed to init hardware, open device failed");
        device_state = DeviceState::DEVICE_OPEN_FAILED;
        DEBUG_STREAM << device_path << ": init_hardware done (open failed) in " << steady_time_diff(t) << " s." << std::endl;
        return false;
    }

    ::${namespaced("get_identity_information_t")} ginf_buffer;
    if (${namespaced("get_identity_information")}(device, &ginf_buffer) != result_ok) {
        ::${namespaced("close_device")}(&device);
        device = device_undefined;

        set_state(Tango::FAULT);
        set_status("Failed to init hardware, getting identity information failed");
        device_state = DeviceState::DEVICE_GINF_FAILED;
        DEBUG_STREAM << device_path << ": init_hardware done (ginf failed) in " << steady_time_diff(t) << " s." << std::endl;
        return false;
    }

    const char *src_device_name = reinterpret_cast<const char *>(ginf_buffer.ControllerName);
    char lower_device_name[sizeof(ginf_buffer.ControllerName)];
    std::transform(
            src_device_name,
            src_device_name + sizeof(ginf_buffer.ControllerName),
            lower_device_name,
            [](unsigned char c) { return std::tolower(c); }
    );
    const std::string
            lower_device_name_str(lower_device_name, strnlen(lower_device_name, sizeof(ginf_buffer.ControllerName)));
    if (strncmp(lower_device_name, "${protocol.name.lower()}", sizeof(ginf_buffer.ControllerName)) != 0) {
        ::${namespaced("close_device")}(&device);
        device = device_undefined;

        set_state(Tango::FAULT);
        set_status("Failed to init hardware, incorrect identity information: expected: \"${protocol.name.lower()}\", given: \"" + lower_device_name_str + "\"");
        device_state = DeviceState::DEVICE_GINF_FAILED;
        DEBUG_STREAM << device_path << ": init_hardware done (ginf failed, expected: \"${protocol.name.lower()}\", given: \"" << lower_device_name_str << "\") in " << steady_time_diff(t) << " s." << std::endl;
        return false;
    }

    set_state(Tango::ON);
    set_status("Operational");
    device_state = DeviceState::DEVICE_OK;
    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": init_hardware done in " << steady_time_diff(t) << " s." << std::endl;
    }
    return true;
}

void ${device_name(protocol)}::deinit_hardware()
{
    const steady_time_point t = steady_now();

    set_state(Tango::INIT);
    set_status("Denitializing");

    do_deinit_hardware();

    set_state(Tango::OFF);
    set_status("Not initialized");

    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": deinit_hardware done in " << steady_time_diff(t) << " s." << std::endl;
    }
}

bool ${device_name(protocol)}::try_reinit_hardware()
{
    const steady_time_point t = steady_now();
    const sec_duration dlast_conn = steady_time_diff(last_device_open_try_time, t);

    const double
            open_failed_duration = 3,
            ginf_failed_duration = 5,
            error_occurred_duration = 0.5;

    switch (device_state) {
        case DeviceState::DEVICE_NOT_OPENED: {
            break;
        }
        case DeviceState::DEVICE_OK: {
            deinit_hardware();
            break;
        }
        case DeviceState::DEVICE_OPEN_FAILED: {
            if (dlast_conn < open_failed_duration) {
//                const sec_duration d = open_failed_duration - dlast_conn;
//                set_state(Tango::FAULT);
//                set_status("Failed to init hardware, try after " + std::to_string(d) + " s...");
                if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
                    DEBUG_STREAM << device_path << ": try_reinit_hardware done (open failed, try later, " << dlast_conn << " / " << open_failed_duration << " s)" << " in " << steady_time_diff(t) << " s." << std::endl;
                }
                return false;
            }
            break;
        }
        case DeviceState::DEVICE_GINF_FAILED: {
            if (dlast_conn < ginf_failed_duration) {
//                const sec_duration d = ginf_failed_duration - dlast_conn;
//                set_state(Tango::FAULT);
//                set_status("Failed to init hardware, try after " + std::to_string(d) + " s...");
                if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
                    DEBUG_STREAM << device_path << ": try_reinit_hardware done (ginf failed, try later, " << dlast_conn << " / " << ginf_failed_duration << " s)" << " in " << steady_time_diff(t) << " s." << std::endl;
                }
                return false;
            }
            break;
        }
        case DeviceState::DEVICE_ERROR_OCCURRED: {
            if (dlast_conn < error_occurred_duration) {
//                const sec_duration d = error_occurred_duration - dlast_conn;
//                set_state(Tango::FAULT);
//                set_status("Failed to init hardware, try after " + std::to_string(d) + " s...");
                if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
                    DEBUG_STREAM << device_path << ": try_reinit_hardware done (error occurred, try later, " << dlast_conn << " / " << error_occurred_duration << " s)" << " in " << steady_time_diff(t) << " s." << std::endl;
                }
                return false;
            }
            break;
        }
    }

    const bool inited = init_hardware();
    if (${device_name(protocol)}_internal_ns::${device_name(protocol)}_profile_cmd) {
        DEBUG_STREAM << device_path << ": try_reinit_hardware done " << (inited? "(success)": "(fail)") << " in " << steady_time_diff(t) << " s." << std::endl;
    }
    return inited;
}

// Low-level
void ${device_name(protocol)}::do_deinit_hardware()
{
    if (device == device_undefined) {
        DEBUG_STREAM << device_path << ": do_deinit_hardware: nothing to deinit." << std::endl;
        return;
    }
    ::${namespaced("close_device")}(&device);
    device = device_undefined;
}

bool ${device_name(protocol)}::handle_result(result_t result, std::string info)
{
    bool success = true;
    switch (result) {
        case result_ok: {
            break;
        }
        case result_error: {
            set_state(Tango::FAULT);
            set_status("Command " + info + " result error -1");
            INFO_STREAM << device_path << ": handle_result: result_error " << info << std::endl;
            success = false;
            break;
        }
        case result_nodevice: {
            set_state(Tango::FAULT);
            set_status("Command " + info + " result no device -2");
            INFO_STREAM << device_path << ": handle_result: result_nodevice " << info << std::endl;
            success = false;
            break;
        }
        case result_value_error: {
            set_state(Tango::FAULT);
            set_status("Command " + info + " result error -3");
            INFO_STREAM << device_path << ": handle_result: result_value_error " << info << std::endl;
            success = false;
            break;
        }
        case result_not_implemented: {
            set_state(Tango::FAULT);
            set_status("Command " + info + " result not implemented -4");
            INFO_STREAM << device_path << ": handle_result: result_not_implemented " << info << std::endl;
            success = false;
            break;
        }
        default: {
            INFO_STREAM << device_path << ": handle_result: Unknown error! " << info << std::endl;
            success = false;
            break;
        }
    }

    if (!success) {
        do_deinit_hardware();
        device_state = DeviceState::DEVICE_ERROR_OCCURRED;
    }

    return success;
}


}	// namespace ${device_name(protocol)}_ns
