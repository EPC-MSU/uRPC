//=============================================================================
//
// file :        ${device_name(protocol)}ReactiveAttributesPoller.cpp
//
// description : Reactive attributes poller file for the ${device_name(protocol)} class
//
// project :     StandaTango
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include "${device_name(protocol)}.h"

#include <exception>


<%namespace file="${context['import_file']('Project.h.mako')}" import="validator_decl, poller_name, poller_need_continue_name, buffer_name, buffer_mutex_name, attribute_handler_base_name"/>\
<%namespace file="${context['import_file']('Project.cpp.mako')}" import="func_call, buffer_member_var, buffer_member_lock_vars_def"/>\
<%!
    from urpc import ast
%>
\
<%def name="poller_def(cmd)">\
void ${device_name(protocol)}::${poller_name(cmd)}() {
    DEBUG_STREAM << "Enter void ${device_name(protocol)}::${poller_name(cmd)}()... " << device_name << std::endl;

    % for arg in cmd.response.children:
        % if attr_is_reactive(arg):
    Tango::Attribute ${attribute_handler_base_name(arg)} = get_device_attr()->get_attr_by_name("${attribute_handler_base_name(arg)}");
        % else:
    // Attribute ${attribute_handler_base_name(arg)} is not reactive
        % endif

    % endfor

    while (pollers_need_continue.load()) {
        DEBUG_STREAM << "Loop void ${device_name(protocol)}::${poller_name(cmd)}()... " << device_name << std::endl;

        try {
            std::lock_guard<std::mutex> device_lock(device_mutex);
            if (get_state() != Tango::ON) {
                if (!try_reinit_hardware()) {
                    DEBUG_STREAM << "Skipping polling void ${device_name(protocol)}::${poller_name(cmd)}()... " << device_name << " (can\'t init hardware)" << std::endl;
                }
            } else  {
                ${buffer_member_lock_vars_def(cmd)}

                ${func_call(cmd)};
    % for arg in cmd.response.children:
        % if attr_is_reactive(arg):
                // Read from buffer
            % if isinstance(arg.type_, ast.ArrayType):
                ${attribute_handler_base_name(arg)}.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)}>(${buffer_member_var(arg)}), ${len(arg.type_)});
            % else:
                ${attribute_handler_base_name(arg)}.set_value(reinterpret_cast<Tango::${tango_type(arg.type_)}*>(&${buffer_member_var(arg)}));
            % endif
        % endif
    % endfor
            }


        } catch (const std::exception &e) {
            ERROR_STREAM << "When polling ${cmd.name} ${device_name(protocol)} exception caught: " << e.what() << '.' << std::endl;
        } catch (const CORBA::Exception &e) {
            Tango::Except::print_exception(e);
            ERROR_STREAM << "When polling ${cmd.name} ${device_name(protocol)} CORBA exception caught." << std::endl;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(${cmd_poll_ms(cmd)}));
    }

    DEBUG_STREAM << "Leave void ${device_name(protocol)}::${poller_name(cmd)}()... " << device_name << std::endl;
}
</%def>\
\
namespace ${device_name(protocol)}_ns {


% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
// Command ${cmd.name}
${poller_def(cmd)}\
    % else:
// Command ${cmd.name} has not reactive attributes
    % endif

% endfor

% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
// Accessor ${getter.name}/${setter.name}
${poller_def(getter)}\
    % else:
// Accessor ${getter.name}/${setter.name} has not reactive attributes
    % endif

% endfor


}	// namespace ${device_name(protocol)}_ns
