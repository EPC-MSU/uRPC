<%namespace import="namespaced" module = "urpc.builder.device.utils.namespaced" inheritable="True"/>
<%namespace file="${context['import_file']('Project.h.mako')}" import="command_handler_decl, reader_handler_decl, writer_handler_decl, buffer_name, buffer_mutex_name, poller_name, poller_thread_name, poller_need_continue_name"/>\
<%!
    from urpc import ast
%>
\
<%def name="buffer_member_var(arg)">${buffer_name(arg.parent)}.${arg.name}</%def>\
<%def name="buffer_member_lock_vars_def(arg_or_cmd)">\
% if isinstance(arg_or_cmd, ast.Argument):
    % if has_ext_args(arg_or_cmd.parent):
std::lock_guard<std::mutex> out_lock(${buffer_mutex_name(arg_or_cmd.parent)});\
    % endif
% elif has_ext_args(arg_or_cmd.request) and has_ext_args(arg_or_cmd.response):
std::lock(${buffer_mutex_name(arg_or_cmd.request)}, ${buffer_mutex_name(arg_or_cmd.response)}); std::lock_guard<std::mutex> in_lock(${buffer_mutex_name(arg_or_cmd.request)}, std::adopt_lock), out_lock(${buffer_mutex_name(arg_or_cmd.response)}, std::adopt_lock);\
% elif has_ext_args(arg_or_cmd.request):
std::lock_guard<std::mutex> in_lock(${buffer_mutex_name(arg_or_cmd.request)});\
% elif has_ext_args(arg_or_cmd.response):
std::lock_guard<std::mutex> out_lock(${buffer_mutex_name(arg_or_cmd.response)});\
% else:
// Command ${arg_or_cmd.name} has no buffer\
% endif
</%def>\
\
<%def name="func_call(cmd)">\
handle_result(::${namespaced(cmd.name)}(device\
% if is_accessor_part(cmd):
, &${buffer_name(cmd.response if len(cmd.response.args) else cmd.request)}\
% else:
    % if has_ext_args(cmd.request):
, &${buffer_name(cmd.request)}\
    % endif
    % if has_ext_args(cmd.response):
, &${buffer_name(cmd.response)}\
    % endif
% endif
));\
</%def>\
\
<%def name="func_device_lock_required_def()">\
${caller.func_decl()} {
    DEBUG_STREAM << "Enter ${caller.func_decl()}... " << device_name << ", " << device_path << std::endl;
    {
        std::lock_guard<std::mutex> device_lock(device_mutex);
        if (get_state() == Tango::ON || try_init_hardware()) {
${caller.body()}
        }
    }
    DEBUG_STREAM << "Leave ${caller.func_decl()}... " << device_name << ", " << device_path << std::endl;
}
</%def>\
\
<%def name="func_device_lock_not_required_def()">\
${caller.func_decl()} {
    DEBUG_STREAM << "Enter ${caller.func_decl()}... " << device_name << ", " << device_path << std::endl;
    {
${caller.body()}
    }
    DEBUG_STREAM << "Leave ${caller.func_decl()}... " << device_name << ", " << device_path << std::endl;
}
</%def>\
\
static const char *RcsId = "$Id:  $";
//=============================================================================
//
// file :        ${device_name(protocol)}.cpp
//
// description : C++ source for the ${device_name(protocol)} class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               ${device_name(protocol)} are implemented in this file.
//
// project :     StandaTango
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================

#include <algorithm>
#include <cstring>

#include <tango.h>

#include "${device_name(protocol)}.h"
#include "${device_name(protocol)}Class.h"


static_assert(
    sizeof(int32_t) == sizeof(Tango::DevLong) && alignof(int32_t) == alignof(Tango::DevLong) &&
    sizeof(uint32_t) == sizeof(Tango::DevULong) && alignof(uint32_t) == alignof(Tango::DevULong),
    "Current version works only on platforms where (u)int32_t is the same as Tango::Dev(U)Long"
);


/**
 *  ${device_name(protocol)} class description:
 *    Tango device server implementation for Standa 8smc4usb motion control device.
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name    |  Method name
//================================================================
//  State           |  Inherited (no method)
//  Status          |  Inherited (no method)
//================================================================

//================================================================
//  Attributes managed are:
//================================================================
//================================================================

namespace ${device_name(protocol)}_ns {


<%def name="init_poller_need_continue(cmd)">\
    , ${poller_need_continue_name(cmd)}(false)
</%def>\
\
${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, string &s)
    : TANGO_BASE_CLASS(cl, s.c_str())
% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${init_poller_need_continue(cmd)}\
    % endif
% endfor
% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${init_poller_need_continue(getter)}\
    % endif
% endfor
{
	init_device();
}
//--------------------------------------------------------
${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, const char *s)
    : TANGO_BASE_CLASS(cl, s)
% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${init_poller_need_continue(cmd)}\
    % endif
% endfor
% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${init_poller_need_continue(getter)}\
    % endif
% endfor
{
	init_device();
}
//--------------------------------------------------------
${device_name(protocol)}::${device_name(protocol)}(Tango::DeviceClass *cl, const char *s, const char *d)
    : TANGO_BASE_CLASS(cl, s, d)
% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${init_poller_need_continue(cmd)}\
    % endif
% endfor
% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${init_poller_need_continue(getter)}\
    % endif
% endfor
{
	init_device();
}

//--------------------------------------------------------
/**
 *	Method      : ${device_name(protocol)}::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void ${device_name(protocol)}::delete_device()
{
	DEBUG_STREAM << "Enter ${device_name(protocol)}::delete_device()... " << device_name << ", " << device_path << std::endl;

	//	Delete device allocated objects
    set_state(Tango::CLOSE);
    set_status("Deinitializing");

    stop_pollers();
    deinit_hardware();

    set_state(Tango::OFF);
    set_status("");

    DEBUG_STREAM << "Leave ${device_name(protocol)}::delete_device()... " << device_name << ", " << device_path << std::endl;
}

//--------------------------------------------------------
/**
 *	Method      : ${device_name(protocol)}::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void ${device_name(protocol)}::init_device()
{
	DEBUG_STREAM << "Enter ${device_name(protocol)}::init_device()... " << device_name << ", " << device_path << std::endl;

	// Initialization before get_device_property() call

    // Zero-initialize all buffers to prevent garbage reads
% for cmd in all_cmds(protocol):
    % if needs_external_buffer(cmd.request):
    std::memset(&${buffer_name(cmd.request)}, 0, sizeof(${buffer_name(cmd.request)}));
    % endif
    % if needs_external_buffer(cmd.response):
    std::memset(&${buffer_name(cmd.response)}, 0, sizeof(${buffer_name(cmd.response)}));
    % endif
% endfor

    {
        std::lock_guard<std::mutex> device_lock(device_mutex);

        last_try_inited = false;

        // Get the device properties from database
        get_device_property();

        try_init_hardware();
        start_pollers();
    }

    DEBUG_STREAM << "Leave ${device_name(protocol)}::init_device()... " << device_name << ", " << device_path << std::endl;
}

//--------------------------------------------------------
/**
 *	Method      : ${device_name(protocol)}::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void ${device_name(protocol)}::get_device_property() {
    // Initialize property data members

    // Read device properties from database.
    Tango::DbData dev_prop;
    dev_prop.push_back(Tango::DbDatum("DevicePath"));

    // is there at least one property to be read?
    if (dev_prop.size() > 0) {
        // Call database and extract values
        if (Tango::Util::instance()->_UseDb) {
            get_db_device()->get_property(dev_prop);
        }

        // get instance on ${device_name(protocol)}Class to get class property
        Tango::DbDatum def_prop, cl_prop;
        ${device_name(protocol)}Class *ds_class = static_cast<${device_name(protocol)}Class *>(get_device_class());
        int	i = -1;

        // Try to initialize DevicePath from class property
        cl_prop = ds_class->get_class_property(dev_prop[++i].name);
        if (!cl_prop.is_empty()) {
            cl_prop >> device_path;
        } else {
            //	Try to initialize DevicePath from default device value
            def_prop = ds_class->get_default_device_property(dev_prop[i].name);
            if (!def_prop.is_empty()) {
                def_prop >> device_path;
            }
        }
        //	And try to extract DevicePath value from database
        if (!dev_prop[i].is_empty()) {
            dev_prop[i] >> device_path;
        }
    }

    //	Check device property data members init
}

void ${device_name(protocol)}::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Enter ${device_name(protocol)}::read_attr_hardware(vector<long> &attr_list) ... " << device_name << ", " << device_path << std::endl;

	// Add your own code

    DEBUG_STREAM << "Leave ${device_name(protocol)}::read_attr_hardware(vector<long> &attr_list)... " << device_name << ", " << device_path << std::endl;
}

void ${device_name(protocol)}::write_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Enter ${device_name(protocol)}::write_attr_hardware(vector<long> &attr_list)... " << device_name << ", " << device_path << std::endl;

	// Add your own code

    DEBUG_STREAM << "Leave ${device_name(protocol)}::write_attr_hardware(vector<> &attr_list)... " << device_name << ", " << device_path << std::endl;
}

void ${device_name(protocol)}::add_dynamic_attributes() {
    // Add your own code to create and add dynamic attributes if any
}

\
<%def name="start_poller(cmd)">\
    ${poller_need_continue_name(cmd)}.store(true);
    ${poller_thread_name(cmd)} = std::thread(&${device_name(protocol)}::${poller_name(cmd)}, this);
</%def>\
\
<%def name="say_poller_to_stop(cmd)">\
    ${poller_need_continue_name(cmd)}.store(false);
</%def>\
\
<%def name="stop_poller(cmd)">\
    // Stop ${poller_name(cmd)}
    if (${poller_thread_name(cmd)}.joinable()) {
        try {
            ${poller_thread_name(cmd)}.join();
        } catch (const std::exception &e) {
            ERROR_STREAM << "When stopping poller ${cmd.name} exception caught: " << e.what() << ". " << device_name << ", " << device_path << std::endl;
        }
    }
</%def>\
\
void ${device_name(protocol)}::start_pollers() {
    DEBUG_STREAM << "Start void ${device_name(protocol)}::start_pollers()... " << device_name << ", " << device_path << std::endl;

% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${start_poller(cmd)}
    % endif
% endfor
% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${stop_poller(getter)}
    % endif
% endfor
    DEBUG_STREAM << "Leave void ${device_name(protocol)}::start_pollers()... " << device_name << ", " << device_path << std::endl;
}

void ${device_name(protocol)}::stop_pollers() {
    DEBUG_STREAM << "Start void ${device_name(protocol)}::stop_pollers()... " << device_name << ", " << device_path << std::endl;

% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${say_poller_to_stop(cmd)}\
    % endif
% endfor

% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${say_poller_to_stop(getter)}\
    % endif
% endfor

% for cmd in all_cmds(protocol):
    % if cmd_has_reactive_attrs(cmd):
${stop_poller(cmd)}\
    % endif
% endfor

% for (getter, setter) in all_accs(protocol):
    % if cmd_has_reactive_attrs(getter):
${stop_poller(getter)}\
    % endif
% endfor

    DEBUG_STREAM << "Leave void ${device_name(protocol)}::stop_pollers()... " << device_name << ", " << device_path << std::endl;
}

## Describe protocol commands in TANGO terms(tango commands, read- and write-only attributes)
% for cmd in all_cmds(protocol):
\
## TANGO command handler declaration for protocol command
<%self:func_device_lock_required_def>\
<%def name="func_decl()">${command_handler_decl(cmd)}</%def>\
            ${buffer_member_lock_vars_def(cmd)}
            ${func_call(cmd)}\
</%self:func_device_lock_required_def>\
\
## TANGO write-only attribute handler declarations for commands' input arguments
<%
    out_args = list(external_args(cmd.request))
    reserved_out_args, non_reserved_out_args = set(), set()
    for arg in out_args:
        if arg.name.lower().find("reserved") == -1:
            non_reserved_out_args.add(arg)
        else:
            reserved_out_args.add(arg)
%>\
    % for arg in out_args:
        % if attr_is_reactive(arg) and len(non_reserved_out_args) <= 1:
<%self:func_device_lock_required_def>\
<%def name="func_decl()">${writer_handler_decl(arg)}</%def>\
            // Write handler
            // Write to buffer
% if isinstance(arg.type, ast.ArrayType):
            const Tango::${tango_type(arg.type)} w_val;
            attr.get_write_value(w_val);
            std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type.size});\
% else:
            Tango::${tango_type(arg.type)} w_val;
            attr.get_write_value(w_val);
            ${buffer_member_var(arg)} = w_val;\
% endif
            // Warning: Heuristic: will with zeros (another) reserved fields and call setter,
            // if has <= 1 non-reserved fields
        % for another_reserved_arg in reserved_out_args - {arg}:
            % if isinstance(another_reserved_arg.type, ast.ArrayType):
            std::memset(&${buffer_member_var(another_reserved_arg)}, 0, ${another_reserved_arg.type.size});
            % else:
            ${buffer_member_var(another_reserved_arg)} = 0;
            % endif
        % endfor
            ${func_call(cmd)}\
</%self:func_device_lock_required_def>\
        % else:
<%self:func_device_lock_not_required_def>\
<%def name="func_decl()">${writer_handler_decl(arg)}</%def>\
        // Write handler
        // Write to buffer
% if isinstance(arg.type, ast.ArrayType):
        const Tango::${tango_type(arg.type)} w_val;
        attr.get_write_value(w_val);
        std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type.size});\
% else:
        Tango::${tango_type(arg.type)} w_val;
        attr.get_write_value(w_val);
        ${buffer_member_var(arg)} = w_val;\
% endif
</%self:func_device_lock_not_required_def>\
        % endif
    % endfor
\
## TANGO read-only attribute handler declarations for commands' output arguments
    % for arg in external_args(cmd.response):
<%self:func_device_lock_not_required_def>\
<%def name="func_decl()">${reader_handler_decl(arg)}</%def>\
        // Read handler
        ${buffer_member_lock_vars_def(arg)}
        // Read from buffer
% if isinstance(arg.type, ast.ArrayType):
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type)}>(${buffer_member_var(arg)}), ${len(arg.type)});\
% else:
        attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type)} *>(&${buffer_member_var(arg)}));\
% endif
</%self:func_device_lock_not_required_def>\
    % endfor
\
% endfor
\
## Describe protocol accessors in TANGO terms(tango read-write attributes)
% for (getter, setter) in all_accs(protocol):
\
    % for arg in getter.response.args:
## Write handler definition
<%self:func_device_lock_required_def>\
<%def name="func_decl()">${writer_handler_decl(arg)}</%def>\
            // Write handler
            ${buffer_member_lock_vars_def(arg)}
            ${func_call(getter)}
            // Write to buffer
% if isinstance(arg.type, ast.ArrayType):
            const Tango::${tango_type(arg.type)} w_val;
            attr.get_write_value(w_val);
            std::memcpy(${buffer_member_var(arg)}, w_val, ${arg.type.size});\
% else:
            Tango::${tango_type(arg.type)} w_val;
            attr.get_write_value(w_val);
            ${buffer_member_var(arg)} = w_val;\
% endif
            ${func_call(setter)}\
</%self:func_device_lock_required_def>\
\
## Read handler definition
<%self:func_device_lock_required_def>\
<%def name="func_decl()">${reader_handler_decl(arg)}</%def>\
            // Read handler
            ${buffer_member_lock_vars_def(arg)}
            ${func_call(getter)}
            // Read from buffer
% if isinstance(arg.type, ast.ArrayType):
            attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type)}>(${buffer_member_var(arg)}), ${len(arg.type)});\
% else:
            attr.set_value(reinterpret_cast<Tango::${tango_type(arg.type)} *>(&${buffer_member_var(arg)}));\
% endif
</%self:func_device_lock_required_def>\
    % endfor
\
% endfor

bool ${device_name(protocol)}::try_init_hardware() {
    DEBUG_STREAM << "Enter void ${device_name(protocol)}::deinit_hardware()... " << device_name << ", " << this->device_path << std::endl;

    set_state(Tango::INIT);
    set_status("Denitializing");

    do_deinit_hardware();

    set_status("Initializing");

    timespec now;
    clock_gettime(CLOCK_MONOTONIC, &now);
    if (last_try_inited) {
        double dlast_conn = now.tv_sec - last_try.tv_sec + ((double)now.tv_nsec - last_try.tv_nsec) / 1000000000.0;
        if(dlast_conn < 3) {
            set_state(Tango::FAULT);
            set_status("Failed to init hardware");
            DEBUG_STREAM << "Leave void ${device_name(protocol)}::try_init_hardware()... " << device_name << ", " << device_path << " (try later)" << std::endl;
            return false;
        }
    } else {
        last_try_inited = true;
    }
    last_try = now;

    this->device = ${namespaced("open_device")}(this->device_path.c_str());
    if(this->device == device_undefined) {
        set_state(Tango::FAULT);
        set_status("Failed to init hardware");
        DEBUG_STREAM << "Leave void ${device_name(protocol)}::try_init_hardware()..." << device_name << ", " << device_path << " (fail)" << std::endl;
        return false;
    }

    set_state(Tango::ON);
    set_status("Operational");
    DEBUG_STREAM << "Leave void ${device_name(protocol)}::try_init_hardware()..." << device_name << ", " << device_path << " (success)" << std::endl;
    return true;
}

void ${device_name(protocol)}::deinit_hardware() {
    DEBUG_STREAM << "Enter void ${device_name(protocol)}::deinit_hardware()... " << device_name << ", " << device_path << std::endl;
    {
        std::lock_guard<std::mutex> device_lock(device_mutex);
        do_deinit_hardware();
    }
    DEBUG_STREAM << "Leave void ${device_name(protocol)}::deinit_hardware()... " << device_name << ", " << device_path << std::endl;
}

void ${device_name(protocol)}::do_deinit_hardware() {
    DEBUG_STREAM << "Enter void ${device_name(protocol)}::do_deinit_hardware()... " << device_name << ", " << device_path << std::endl;
    if (this->device == device_undefined) {
        DEBUG_STREAM << "Leave void ${device_name(protocol)}::do_deinit_hardware()... " << device_name << " (nothing to deinit)" << std::endl;
        return;
    }
    ::${namespaced("close_device")}(&device);
    last_try_inited = false;
    DEBUG_STREAM << "Leave void ${device_name(protocol)}::do_deinit_hardware()... " << device_name << ", " << device_path << std::endl;
}

bool ${device_name(protocol)}::handle_result(result_t result) {
    switch(result) {
        case result_ok:
            return true;
        case result_error:
            set_state(Tango::FAULT);
            set_status("Result error");
            INFO_STREAM << "${device_name(protocol)}::handle_result(result_t result) " << device_name << ": Result error." << std::endl;
            return false;
        case result_nodevice:
            set_state(Tango::FAULT);
            set_status("Result nodevice");
            INFO_STREAM << "${device_name(protocol)}::handle_result(result_t result) " << device_name << ": Result nodevice." << std::endl;
            return false;
        case result_value_error:
            set_state(Tango::FAULT);
            set_status("Result value error");
            INFO_STREAM << "${device_name(protocol)}::handle_result(result_t result) " << device_name << ": Result value error." << std::endl;
            return false;
        case result_not_implemented:
            set_state(Tango::FAULT);
            set_status("Result not implemented");
            INFO_STREAM << "${device_name(protocol)}::handle_result(result_t result) " << device_name << ": Result not implemented." << std::endl;
            return false;
        default:
            ERROR_STREAM << "${device_name(protocol)}::handle_result(result_t result) " << device_name << ": Result unknown!" << std::endl;
            return false;
    }
}


}	// namespace ${device_name(protocol)}_ns
