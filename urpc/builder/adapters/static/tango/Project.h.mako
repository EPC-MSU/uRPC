<%namespace import="namespaced" module = "urpc.builder.device.utils.namespaced" inheritable="True"/>
//=============================================================================
//
// Project generated by builder ${BUILDER_VERSION}
//
// file :        ${device_name(protocol)}.h
//
// description : Include file for the ${device_name(protocol)} class
//
// project :     StandaTango
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author:  $
//
// $Revision:  $
// $Date:  $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#ifndef ${upper_device_name(protocol)}_H
#define ${upper_device_name(protocol)}_H

#include <thread>
#include <mutex>
#include <atomic>
#include <assert.h>
#include <time.h>
#include <tango.h>

#include <${library_header_file(protocol)}.h>


/** @file ${device_name(protocol)}.h
	* \~english
	* @brief Header file for ${device_name(protocol)} Tango server realisation.
	* \~russian
	* @brief Заголовочный файл для реализации Tango сервера ${device_name(protocol)}
	*
	* Данный сервер Tango представляет собой "обёртку" над библиотекой  ${library_header_file(protocol)},
	* позволяющий использовать её в системах, построенных на использовании стандарта Tango.
	*
	* Компиляция проекта осуществляется под Linux следующим образом
    *   1.   Создайте директорию для сборки библиотеки и зайдите в неё.
    *        mkdir -p /tmp/build/${device_name(protocol)}_tango && cd /tmp/build/${device_name(protocol)}_tango
    *   2.	 Запустите CMake, указав в качестве аргумента путь к директории, содержащей файл CMakeLists.txt для этой библиотеки.
    *   3.	 Дождитесь завершения процесса конфигурации. В случае если в системе найден и функционирует компилятор, линкер, а также удовлетворены все зависимости, описанные в файле CMakeLists.txt,
    *        конфигурация завершится успешно, результатом является файл Makefile.
    *   4.   make -j3
	*
	* Предварительно должна быть собрана библиотека ${library_header_file(protocol)} в локальной версии (без bindy),
	* если он устанавливается на той же машине, где и контроллеры и в сетевой версии
	* (т.е. с использованием библиотеки bindy.), в противном случае.
	*
	* Файл ${library_header_file(protocol)}.h должен быть
	* помещён вместе с исходниками Tango сервера, разделяемая библиотека lib${library_header_file(protocol)}.so
	* должна быть помещена в место, где система ожидает  искать разделяемые библиотеки.
	* На компьютере должна быть установлена библиотека разработчика для tango8 (tango8.dev) и pkg-config.
	*
	* @brief Особенности библиотеки
	* Функции библиотеки концептуально разбиты на 2 группы:
    * 1. Аксессоры — пара функций, имеющих одинаковое название(за исключением первых 4 символов, которые могут быть либо get_, либо set_)
    * и строго один аргумент(помимо device_id), причём тип этого аргумента также должен совпадать у обоих функций(для get_- и set_-функции в качестве выходного и входного соответственно).
    * Эти функции являются прямыми аналогами пары getter-setter, применяемых в объектно-ориентированных языках программирования(C#, Java, Python, …) в том смысле,
    * что одна из них считывает какие-либо данных из аппаратного модуля, а вторая — обновляет их.
    * 2. Простые функции — непарная функция, которая может иметь от 0 до 2 аргументов(не считая device_id) т.е. могут отсутствовать входной аргумент, выходной аргумент или оба.
    * Для простых функций входные и выходные структуры транслируются во write- и read-only TANGO-атрибуты соответственно.
    *
    * Входные write-only атрибуты имеют имя в формате
    * ${device_name(protocol)}_[имя СИ-функции]_[имя поля в структуре входных аргументов]_in,
    * выходные read-only в формате
    * ${device_name(protocol)}_[имя СИ-функции]_[имя поля в структуре выходных аргументов]_out.
    * Важно понимать, что запись в входные write-only атрибуты не приведёт к вызову соответствующей функции — эти значения будут буферзиованы в памяти до тех пор,
    * пока не будет вызвана функция-триггер. Чтение выходных read-only атрибутов работает по тому же принципу — атрибут хранит значение, полученное в ходе последнего вызова функции-триггера.
    * Это сделано для того, чтобы не допустить неожиданных побочных эффектов от неявного вызова функции при чтении/записи атрибутов.
    *
    * В случае аксессоров каждое поле структуры аргументов транслируется в read-write атрибут с названием
    * ${device_name(protocol)}_[имя пары СИ-функций без «get_» и «set_»]_[имя поля в структуре аргументов].
    * В отличие от простых функций, чтение такого атрибута приводят к немедленному вызову соответствующей get-функции, актуализирующей содержимое структуры аргументов.
    * В случае записи также происходит немедленное обновлению поля в структуре новым значением атрибута и вызову set-функции с обновлённой структурой.
*/

/**
 *  \~english
 *  ${device_name(protocol)} class description:
 *    Tango device server implementation for Standa 8smc4usb motion control device.
 *  \~russian
 *  Описание класса ${device_name(protocol)}:
 *    Реализация сервера устройств Tango для Standa 8smc4usb устройств управления движениями.
 */


#define ${upper_device_name(protocol)}_BUILDER_VERSION_MAJOR ${BUILDER_VERSION_MAJOR}
#define ${upper_device_name(protocol)}_BUILDER_VERSION_MINOR ${BUILDER_VERSION_MINOR}
#define ${upper_device_name(protocol)}_BUILDER_VERSION_BUGFIX ${BUILDER_VERSION_BUGFIX}
#define ${upper_device_name(protocol)}_BUILDER_VERSION_SUFFIX "${BUILDER_VERSION_SUFFIX}"
#define ${upper_device_name(protocol)}_BUILDER_VERSION "${BUILDER_VERSION}"


namespace ${device_name(protocol)}_ns
{

//	Additional Class Declarations

class ${device_name(protocol)} : public TANGO_BASE_CLASS
{

//	Add your own data members

//	Device property data members
public:
	//	DevicePath:	Filesystem path to file-like device object.
	std::string	device_path;

    ::device_t device;
    timespec last_try;
    bool last_try_inited;

//	bool	mandatoryNotDefined;
//	Constructors and destructors
public:
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	${device_name(protocol)}(Tango::DeviceClass *cl,string &s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device Name
	 */
	${device_name(protocol)}(Tango::DeviceClass *cl,const char *s);
	/**
	 * Constructs a newly device object.
	 *
	 *	@param cl	Class.
	 *	@param s 	Device name
	 *	@param d	Device description.
	 */
	${device_name(protocol)}(Tango::DeviceClass *cl,const char *s,const char *d);

    ~${device_name(protocol)}() { delete_device(); }
public:
    // Note: init_device/delete_device will be called automatically
	virtual void init_device();
    virtual void delete_device();
    /*
	 *	Read the device properties from database
	 */
	void get_device_property();

// Attribute methods
public:
	//--------------------------------------------------------
	/*
	 *	Method      : ${device_name(protocol)}::read_attr_hardware()
	 *	Description : Hardware acquisition for attributes.
	 */
	//--------------------------------------------------------
	virtual void read_attr_hardware(vector<long> &attr_list);
	//--------------------------------------------------------
	/*
	 *	Method      : ${device_name(protocol)}::write_attr_hardware()
	 *	Description : Hardware writing for attributes.
	 */
	//--------------------------------------------------------
	virtual void write_attr_hardware(vector<long> &attr_list);

<%!
    from urpc import ast
%>\
<%def name="command_handler_name(cmd)"><%
    assert isinstance(cmd, ast.Command)
    name = cmd.name[4:] if is_accessor_part(cmd) else cmd.name
%>urpc_${name}</%def>\
<%def name="attribute_handler_base_name(arg)"><%
    assert isinstance(arg, ast.Argument)
    msg = arg.parent
    cmd = msg.parent
    direction = "" if is_accessor_part(arg.parent.parent) else ("_in" if is_request(msg) else "_out")
%>${command_handler_name(cmd)}_${arg.name}${direction}</%def>\
<%def name="reader_handler_name(arg)">read_${attribute_handler_base_name(arg)}</%def>\
<%def name="writer_handler_name(arg)">write_${attribute_handler_base_name(arg)}</%def>\
## Command and attribute handler function prototypes(declarations)
<%def name="_handler_decl(namespaced)">\
void \
    % if namespaced:
${device_name(protocol)}::\
    % endif
${caller.body()}\
</%def>\
<%def name="command_handler_decl(cmd, ns=True)"><%self:_handler_decl namespaced="${ns}">${command_handler_name(cmd)}()</%self:_handler_decl></%def>\
<%def name="reader_handler_decl(arg, ns=True)"><%self:_handler_decl namespaced="${ns}">${reader_handler_name(arg)}(Tango::Attribute &attr)</%self:_handler_decl></%def>\
<%def name="writer_handler_decl(arg, ns=True)"><%self:_handler_decl namespaced="${ns}">${writer_handler_name(arg)}(Tango::WAttribute &attr)</%self:_handler_decl></%def>\
## Validator function prototypes(declarations)
<%def name="validator_name(arg_or_cmd)">\
<%
    assert isinstance(arg_or_cmd, ast.Argument) or isinstance(arg_or_cmd, ast.Command)
%>\
is_\
    % if isinstance(arg_or_cmd, ast.Argument):
${attribute_handler_base_name(arg_or_cmd)}\
    % elif isinstance(arg_or_cmd, ast.Command):
${command_handler_name(arg_or_cmd)}\
    % endif
_allowed\
</%def>\
<%def name="validator_decl(arg_or_cmd, namespaced=True)">\
bool \
    % if namespaced:
${device_name(protocol)}::\
    % endif
${validator_name(arg_or_cmd)}(\
    % if isinstance(arg_or_cmd, ast.Argument):
TANGO_UNUSED(Tango::AttReqType type)\
    % elif isinstance(arg_or_cmd, ast.Command):
TANGO_UNUSED(const CORBA::Any &any)\
    % endif
)\
</%def>\
<%def name="poller_name(cmd)">poll_${command_handler_name(cmd)}</%def>\
<%def name="poller_decl(cmd, namespaced=True)">\
void \
    % if namespaced:
${device_name(protocol)}::\
    % endif
${poller_name(cmd)}()\
</%def>\
<%def name="poller_thread_name(cmd)">poll_${command_handler_name(cmd)}_thread</%def>\
<%def name="poller_need_continue_name(cmd)">poll_${command_handler_name(cmd)}_need_continue</%def>\
<%def name="buffer_type(msg)">${namespaced(argstruct_for_cmd(msg).name)}</%def>\
<%def name="buffer_name(msg)"><%
    prefix = ""
    if not is_accessor_part(msg.parent):
        prefix = "in_" if is_request(msg) else "out_"
%>${prefix}${buffer_type(msg)}_buffer</%def>\
<%def name="buffer_mutex_name(msg)">${buffer_name(msg)}_mutex</%def>\
\
## Protocol commands declarations(tango commands, tango read/write only attributes, buffer variables)
% for cmd in all_cmds(protocol):
    // Command ${cmd.name}
public:
    virtual ${command_handler_decl(cmd, False)};
    ${validator_decl(cmd, False)};
    % if has_ext_args(cmd.request):

    // Request arguments for ${cmd.name}
    % endif
    % for arg in external_args(cmd.request):
    virtual ${writer_handler_decl(arg, False)};
    ${validator_decl(arg, False)};
    % endfor
    % if has_ext_args(cmd.response):

    // Response arguments for ${cmd.name}
    % endif
    % for arg in external_args(cmd.response):
    virtual ${reader_handler_decl(arg, False)};
    ${validator_decl(arg, False)};
    % endfor
    % if needs_external_buffer(cmd.request) or needs_external_buffer(cmd.response):
private:
        % if cmd_has_reactive_attrs(cmd):
    void ${poller_name(cmd)}();
    std::atomic<bool> ${poller_need_continue_name(cmd)};
    std::thread ${poller_thread_name(cmd)};
        % endif
    % endif
    % if needs_external_buffer(cmd.request):
    ${buffer_type(cmd.request)} ${buffer_name(cmd.request)};
    std::mutex ${buffer_mutex_name(cmd.request)};
    % endif
    % if needs_external_buffer(cmd.response):
    ${buffer_type(cmd.response)} ${buffer_name(cmd.response)};
    std::mutex ${buffer_mutex_name(cmd.response)};
    % endif

% endfor
## Protocol accessors declarations(tango read-write attributes, buffer bariables)
% for (getter, setter) in all_accs(protocol):
    // Accessor ${getter.name}/${setter.name}
public:
    % for arg in getter.response.args:
    virtual ${writer_handler_decl(arg, False)};
    virtual ${reader_handler_decl(arg, False)};
    ${validator_decl(arg, False)};
    % endfor
private:
    % if cmd_has_reactive_attrs(getter):
    void ${poller_name(getter)}();
    std::atomic<bool> ${poller_need_continue_name(getter)};
    std::thread ${poller_thread_name(getter)};
    % endif
    ${buffer_type(getter.request)} ${buffer_name(getter.request)};
    std::mutex ${buffer_mutex_name(getter.request)};

% endfor
public:
	void add_dynamic_attributes();
private:
    void start_pollers();
    void stop_pollers();

    bool try_init_hardware();
    void deinit_hardware();
    void do_deinit_hardware();
    std::mutex device_mutex;

    bool handle_result(result_t result);
};	// class ${device_name(protocol)}

}	// namespace ${device_name(protocol)}_ns

#endif   //	${upper_device_name(protocol)}_H
