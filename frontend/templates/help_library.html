{% extends "help.html" %}

{% block help %}

<h2>PC библиотека (генерируется uRPC)</h2>
<h3>Описание</h3>
<p align="justify">
    Библиотека - это то, что нужно компьютеру для общения с устройством по вашему протоколу. В библиотеке реализован
    API для отправки запросов контроллеру, ожидания и распознавания ответов от него. Все другие программы, которые
    работают с устройством - например, простой <a href="/helpqt">Qt отладчик</a>, который генерируется uRPC,
    <a href="/helppython">python скрипты</a>, <a href="/helptango">TANGO</a> и ваши собственные программы для общения
    с устройством - все нуждаются в этой библиотеке.
    <br>
    Библиотека предоставляется в виде исходных кодов C\C++ и CMakeLists файла, с помощью которого можно создать файл
    проекта для любой среды программирования (и любого компилятора C\C++). Например, можно сгенерировать проект для
    Microsoft Visual Studio, Code::Blocks, GNU Makefile и пр. Для лучшего ознакомления с CMake посмотрите официальную
    документацию на сайте <a href="https://cmake.org/">cmake</a>.
    <br>
    Для сборки библиотеки потребуется релиз библиотеки xibridge, который берется автоматическии.     
</p>

<h3>Инструкция по сборке CMake-проекта библиотеки</h3>

<h4>Сборка под Windows</h4>
<img src="{{static_url('img/cmake_gui_instruction.png')}}"/>
<ol>
    <li>Сгенерировать библиотеку нажатием кнопки "Generate" под надписью "Library" на главной странице, скачать её и распаковать архив.</li>
    <li>Запустить CMake GUI.</li>
    <li>Нажать кнопку "Browse Source..." и указать путь до папки с исходными кодами (в этой папке находится файл CMakeLists.txt).</li>
    <li>Нажать кнопку "Browse Build..." и указать путь к папке, в которую будут перемещены сгенерированные в ходе работы CMake файлы проекта.</li>
    <li>Нажать кнопку "Configure".</li>
    <li>Выбрать среду для сборки. На Windows обычно используется "Visual Studio 12 2013". Стоит обратить внимание на разрядность (Win32 / Win64).
    В старых версиях CMake она указана в общем списке после имени среды, в новых версиях CMake разрядность задаётся в отдельном списке.</li>
    <li>Нажать "Finish".</li>
    <li>Нажать кнопку "Generate".</li>
</ol>

<p align="justify">Теперь у вас есть файлы проекта для интересующей вас IDE/Сборщика!</p>
<p align="justify">Для работы библиотеки под Windows понадобятся распространяемые пакеты Visual Studio в зависимости от версии. Пакеты для Visual
Studio скачиваются с официального сайта, для VS2013, например, <a href="https://www.microsoft.com/ru-RU/download/details.aspx?id=40784">здесь</a>.
Заметьте, установщик зависит от битности системы.
</p>

<h4>Сборка под Linux</h4>
<ol>
    <li>Установить пакеты разработчика (g++, gcc, make...) через командную строку:
        <p><font face = "Terminal">sudo apt-get install build-essential cmake</font></p>
    </li>
    <li>Загрузить архив с библиотекой, распаковать его.</li>
    <li>В директории src в распакованном архиве библиотеки запустить командную строку и выполнить cmake:
        <p><font face = "Terminal">cmake CMakeLists.txt</font></p>
    </li>
    <li>В этой же директории выполнить make:
        <p><font face = "Terminal">make</font></p>
    </li>
    <li>В результате сборки получилась библиотека .so. Чтобы ваши программы (и Qt-отладчик) находили библиотеку, добавьте путь к библиотеке в переменную LD_LIBRARY_PATH.
    Например, если хотите из оболочки запустить программу, которая использует библиотеку, наберите в командной строке:
        <p><font face = "Terminal">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:путь_к_директории_с_библиотекой</font></p>
    </li>
    <li>Готово. Для использования библиотеки в ваших программах достаточно добавить заголовочный файл <имя_протокола>.h
    (лежит в директории с распакованным архивом библиотеки).</li>
</ol>

<h4>Сборка под macOS</h4>
<ol>
    <li>Установить средства разработки командной строки "Command Line Tools". Вы можете попробовать установить "Command Line Tools" через терминал с помощью команды:
        <p><font face="Terminal">xcode-select --install</font></p>
    Если установить таким образом не получается, то нужно скачать установщик с <a href="https://developer.apple.com/download/all/" target=”_blank”>сайта Apple</a>.
    </li>
    <li>Загрузить архив с библиотекой, распаковать его.</li>
    <li>В папке с исходными кодами библиотеки (в этой папке находится файл CMakeLists.txt) запустить терминал и выполнить команду:
        <p><font face="Terminal">cmake CMakeLists.txt</font></p>
    </li>
    <li>В этой же директории выполнить make:
        <p><font face="Terminal">make</font></p>
    </li>
</ol>

<h3>Документация к API</h3>
<p align="justify">
    Интерфейс C библиотеки документирован в формате <a href="http://www.doxygen.nl">Doxygen</a>. Благодаря правильно
    оформленным комментариям в C библиотеке с помощью Doxygen можно получить документ с описанием интерфейса всех
    C функций, с описанием стуктур данных, констант и пр. (обо всех возможностях Doxygen смотрите на официальном сайте).
</p>

<h4>Сборка документации в Linux</h4>
<ol>
    <li>Установить все необходимые пакеты для работы:
        <p><font face="Terminal">sudo apt-get install doxygen texlive-latex-base texlive-fonts-recommended texlive-fonts-extra texlive-latex-extra</font></p>
    </li>
    <li>В директории с архивом сгенерированной библиотеки запустить Doxygen:
        <p><font face="Terminal">Doxygen .</font></p>
    </li>
    <li>Затем в появившейся папке latex выполнить:
        <p><font face="Terminal">make</font></p>
    </li>
    <li>Готово, файл refman.pdf появился в директории latex.</li>
</ol>

<h4>Сборка документации в Windows</h4>
<p align="justify">
    Инструкция сборки для Windows аналогична, но пакеты Doxygen и texlive нужно установить вручную. Texlive для Windows
    можно взять, например, с <a href="https://miktex.org">miktex</a>, а Doxygen с официального сайта проекта
    <a href="http://www.doxygen.nl/download.html">Doxygen</a>.
</p>

<h3>Пример работы с библиотекой</h3>
Пусть в протоколе устройства Foo есть команда supercommand, и устройство подключено к порту 42.
Тогда C код для вызова этой команды выглядел бы примерно так:

<pre><code class="C">
    #include "foo.h"

    device_t my_device = foo_open_device("com:\\.\COM42");
    foo_supercommand(my_device);
    foo_close_device(&my_device);

</code></pre>

Разумеется, файл foo.h из сгенерированного uRPC архива библиотеки должен лежать рядом. Также при компиляции этого примера
нужно будет прилинковать собранную библиотеку .lib или .so.
<br>
<br>
{% end %}
