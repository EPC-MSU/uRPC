{% extends "help.html" %}

{% block help %}

<h2>PC библиотека (генерируется uRPC)</h2>
<h3> Описание </h3>
<p align="justify">
    Библиотека - это то, что нужно компьютеру для общения с устройством по вашему протоколу.  В библиотеке реализован
    API для отправки запросов контроллеру, ожидания и распознавания ответов от него. Все другие программы, которые
    работают с устройством - например, простой <a href="/helpqt">Qt отладчик</a>, который генерируется uRPC,
    <a href="/helppython">python скрипты</a>, <a href="/heptango">TANGO</a> и ваши собственные программы для общения
    с устройством - все нуждаются в этой библиотеке.
    <br>
    Библиотека предоставляется в виде исходных кодов C\C++ и CMakeLists файла, с помощью которого можно создать файл
    проекта для любой среды программирования (и любого компилятора C\C++). Например, можно сгенерировать проект для
    Microsoft Visual Studio, Code::Blocks, GNU Makefile и пр. Для лучшего ознакомления с CMake посмотрите официальную
    документацию на сайте <a href="https://cmake.org/">cmake</a>.
	<br>
    Библиотека потребует другую библиотеку (xibridge), релиз которой нужно скачать <a href="https://github.com/EPC-MSU/xibridge/releases/tag/v1.0.1"> отсюда</a>.
    Распаковать архив  и положить из папки в соответствии со своей  ОС, допустим, в папку c:/projects/xibridge (путь до библиотеки 
    может быть любой).     
</p>
<h3> Инструкция по сборке CMake-проекта библиотеки</h3>
<h3>Сборка под Windows</h3>
<img src="{{static_url('img/cmake_gui_instruction.png')}}"/>
<p align="justify">
<ol>
    <li>Сгенерировать библиотеку нажатием кнопки "Generate", скачать её и распаковать архив</li>
    <li>Запустить CMake GUI</li>
    <li>Нажать кнопку "Browse Source..." и указать путь до папки с исходными кодами (в этой папке находится файл
    CMakeLists.txt)
    </li>
    <li>Нажать кнопку "Browse Build..." и указать путь к папке, в которую будут перемещены сгенерированный в ходе
    работы CMake
    </li>
    файлы проекта
	<li>добавить запись (Add entry): имя - XIBRIDGE_PATH, тип - string, значение - путь к xibridge, (допустим c:/projects/xibridge)</li>  
    <li>поставить галочку ENABLE_XIBRIDGE</li>
    <li>Нажать кнопку "Configure"</li>
    <li>Выбрать среду для сборки. На Windows обычно используется "Visual Studio 12 2013". Стоит обратить внимание на разрядность (Win32 / Win64).
    В старых версиях Cmake она указана в общем списке после имени среды, в новых версиях Cmake 
    разрядность задаётся в отдельном списке.</li>
    <li>Нажать кнопку "Generate"</li>
    <li>Нажать "Finish"</li>
</ol>
Теперь у вас есть файлы проекта для интересующей вас IDE/Сборщика!

<p>Для работы библиотеки под Windows понадобятся распространяемые пакеты Visual Studio в зависимости от версии. Пакеты для Visual
    Studio скачиваются с официального сайта, для VS2013, например,
    <a href="https://www.microsoft.com/ru-RU/download/details.aspx?id=40784">здесь</a>.</p>
Заметьте, установщик зависит от битности системы.
</p>
<p>Для работы библиотеки также понадобится xibridge.dll, который нужно будет скопировать в папку собранной библиотеки.
</p>
<h3>Сборка под linux</h3>
<ol>
<li>Установить пакеты разработчика (g++, gcc, make...) через командную строку:
    <p><font face = "Terminal">sudo apt-get install build-essential cmake</font></p>
</li>
<li>Загрузить архив с библиотекой, распаковать его</li>
<li>В директории src в распакованном архиве библиотеки запустить командную строку и выполнить cmake:
<p>
    <font face = "Terminal">
cmake -D ENABLE_XINET=ON -DXIBRIDGE_PATH=(путь до xibridge) -DXIBRIDGE_ENABLE=On CMakeLists.txt
    </font>
</p>
</li>
<li>В этой же директории выполнить make:</li>
    <p><font face = "Terminal">make</font></p>
<li>В результате сборки получилась библиотека .so. Чтобы ваши программы (и qt-отладчик) находили библиотеку, добавьте путь к библиотеке в переменную LD_LIBRARY_PATH.
    Например, если хотите из оболочки запустить программу, которая использует библиотеку, наберите в командной строке:</li>
    <p><font face = "Terminal">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:путь_к_директории_с_библиотекой</font></p>
<li>Готово. Для использования библиотеки в ваших программах достаточно добавить заголовочный файл <имя_протокола>.h
    (лежит в директории с распакованным архивом библиотеки)</li>
</ol>
<p></p>

<h3>Документация к API</h3>
<p align="justify">
    Интерфейс C библиотеки документирован в формате <a href="http://www.doxygen.nl">Doxygen</a>. Благодаря правильно
    оформленным комментариям в C библиотеке с помощью Doxygen можно получить документ с описанием интерфейса всех
    C функций, с описанием стуктур данных, констант и пр. (обо всех возможностях Doxygen смотрите на официальном сайте)
</p>
<h4>Сборка Doxygen документации</h4>
В Linux:
<p align="justify">
    <ol>
        <li>
            Установить все необходимые пакеты для работы:
            <p><font face = "Terminal">sudo apt-get install doxygen texlive-latex-base texlive-fonts-recommended
            texlive-fonts-extra texlive-latex-extra</font></p>
        </li>
    <li>
        В директории с архивом сгенерированной библиотеки запустить Doxygen:
        <p><font face = "Terminal">Doxygen .</font></p>
    </li>
    <li>
        Затем в появившейся папке latex выполнить:
        <p><font face = "Terminal">make</font></p>
    </li>
    <li>
        Готово, файл refman.pdf появился в директории latex
    </li>
    </ol>
</p>
В Windows:
<p align="justify">
    Инструкция сборки для Windows аналогична, но пакеты Doxygen и texlive нужно установить вручную. Texlive для Windows
    можно взять, например, с <a href="https://miktex.org">miktex</a>; Doxygen с официального сайта проекта
    <a href="http://www.doxygen.nl/download.html">Doxygen</a>
</p>


<h3> Пример работы с библиотекой </h3>
Пусть в протоколе устройства Foo есть команда supercommand, и устройство подключено к порту 42.
Тогда C код для вызова этой команды выглядел бы примерно так:

<pre><code class="C">
    #include "foo.h"

    device_t my_device = foo_open_device("com:\\.\COM42");
    foo_supercommand(my_device);
    foo_close_device(&my_device);

</code></pre>
Разумеется, файл foo.h из сгенерированного uRPC архива библиотеки должен лежать рядом. Также при компиляции этого приера
нужно будет прилинковать собранную библиотеку .lib или .so

<br>
<br>

{% end %}
