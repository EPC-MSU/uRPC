{% extends "base.html" %}

{% block body %}

<div class="pure-u-md-1-1">
<div class="pure-menu pure-menu-horizontal">

    <ul class="pure-menu-list">
        <li class="pure-menu-item"><a href="#General" class="pure-menu-link">General</a></li>
        <li class="pure-menu-item"><a href="#Library" class="pure-menu-link">Library</a></li>
        <li class="pure-menu-item"><a href="#QT" class="pure-menu-link">QT</a></li>
        <li class="pure-menu-item"><a href="#Firmware" class="pure-menu-link">Firmware</a></li>
        <li class="pure-menu-item"><a href="#Documentation" class="pure-menu-link">Documentation</a></li>
        <li class="pure-menu-item"><a href="#Example" class="pure-menu-link">Example</a></li>
    </ul>
</div>
</div>

<div class="pure-u-md-1-24">
</div>
<div class="pure-u-md-1-2">

<p><a name="General"></a></p>
<h1> uRPC </h1>
<p align="justify">
uRPC - web интерфейс, при помощи которого создаётся, сохраняется и загружается протокол взаимодействия
устройств, основанный на правилах протокола проекта ximc. По готовому протоколу, в свою очередь, возможно
загрузить готовую и работающую прошивку, wiki описание протокола, исходные коды кроссплатформенной библиотеки
управления с подготовленными скриптами её сборки, графический интерфейс для всех функций библиотеки, набор
врапперов для управления библиотекой из разнообразных языков программирования, примеры программ управления
библиотекой из разных языков программирования, и другие дополнительные решения.
В результате, после создания на web сайте протокола, можно сгенерировать набор файлов, чтобы уже через 30 минут
управлять микроконтроллером через GUI. Главная цель: облегченный запуск новых электронных устройств с
микроконтроллером, работающих под управлением компьютера.
</p>

<h2>Общие принципы работы <span class="caps">URPC</span></h2>
<p>Все коммуникации между ПК и микроконтроллером осуществляются по принципу <strong>клиент-сервер</strong>. При этом <strong>микроконтроллер является сервером</strong>, а <strong>ПК &#8211; клиентом</strong>. Это значит, что все <strong>коммуникации инициируются компьютером</strong>. Микроконтроллер не может отправить какие-либо данные на ПК самостоятельно, для этого ему требуется соответствующий запрос клиента (компьютера).</p>
<p><span class="caps">URPC</span> позволяет осуществлять коммуникации двух типов:</p>
<ul>
    <li>Коммуникации посредством команд</li>
    <li>Коммуникации посредством аксессоров</li>
</ul>
<p>Коммуникация посредством <strong>команд</strong> осуществляется следующим образом: </p>
<ol>
    <li><strong>Клиент (ПК) готовит данные</strong> для отправки на сервер (данный этап не является обязательным, поскольку допускаются команды, не передающие никаких данных на сервер).</li>
    <li><strong>Клиент (ПК) отправляет запрос</strong> на выполнение команды клиенту (микроконтроллеру). В запросе также передаются входные данные</li>
    <li>После получения запроса <strong>на сервере (микроконтроллере) запускается обработчик</strong>, в котором производится обработка входных данных, собственно выполнение команды, подготовка выходных данных. По умолчанию <span class="caps">URPC</span> генерирует пустой обработчик, код обработчика пишется пользователем. Сразу после завершения обработчика сервер отправляет ответ клиенту вместе с набором выходных данных.</li>
    <li>Получив <strong>ответ сервера</strong>, клиент (ПК) передаёт управление пользовательской программе, которая может приступить к обработке выходных данных, полученных с сервера (допускаются команды без выходных данных).</li>
</ol>
<p>Входные и выходные никак не зависят друг от друга и могут иметь  формат. Единственное ограничение: суммарный объём всех входных данных, также как и суммарный объём всех выходных данных не должен превышать 250 байт.<br />
    Команды могут иметь входные и выходные аргументы, только входные аргументы, только выходные аргументы, а могут вообще не иметь аргументов.</p>
<p>Общение посредством <strong>аксессоров</strong>.</p>
<p>Аксессор &#8211; это специальная команда (а точнее set/get пара команд), предназначенная для работы с данными на сервере.<br />
    Отправка данных с клиента на сервер осуществляется посредством set-функции аксессора, получение данных &#8211; посредством вызова get-функции аксессора. Обе функции могут быть вызваны только клиентом (ПК). <br />
    Set-функция имеет только входные аргументы, get-функция &#8211; только выходные. Формат входных и выходных данных set и get функций одного аксессора должен быть одинаковым.<br />
    Также как и в случае команд после получения set и get запросов аксессора  сервер (микроконтроллер) запускает соответствующие обработчики, содержание которых определяется пользователем.</p>
<h2>Создание проекта</h2>
<h3>1. Задать название проекта</h3>
<p>Придумать и задать название проекта, версию и нажать Update</p>
<p><img src="{{static_url('img/URPC_project_name.png')}}" alt="" /></p>
<h3>2. Создать команды.</h3>
<h4>2.1. Определить команду</h4>
<p><img src="{{static_url('img/URPC_command_create.png')}}" alt="" /></p>
<p><strong><span class="caps">CID</span></strong> &#8211; это 4-буквенный <strong>идентификатор</strong>, который <strong>должен быть уникальным</strong> для каждой команды. <span class="caps">CID</span> не чувствителен к регистру, поэтому <span class="caps">MYID</span> и myId &#8211; это один и тот же идентификатор.</p>
<p><strong>Name</strong> &#8211; это имя команды (такое же имя будет у функции вызова этой команды, а также будет включено в имена типов данных, связанных с этой командой). Рекомендуется писать имя команды в <strong>snake_case</strong>.</p>
<h4>2.2. Добавить описание команд</h4>
<p>После добавления команды нажать <strong>Edit</strong> и <strong>добавить описание команды</strong> на русском и английском языках в блоке <strong>Edit command properties</strong> в полях <strong>english</strong> и <strong>russian</strong>.</p>
<h4>2.3. Добавить аргументы запроса и ответа команды</h4>
<p><img src="{{static_url('img/URPC_command_args_params.png')}}" alt="" /></p>
<p><strong>Name</strong> &#8211; имя аргумента. После генерации проекта к аргументам можно будет обращаться как к полям структуры по их именам. Рекомендуется писать имена аргументов в <strong>CamelCase</strong>. </p>
<p><strong>Length</strong> &#8211; длина массива. Если <strong>оставить это поле пустым</strong>, то аргумент <strong>будет обычной переменой</strong>. Если в поле Length <strong>указать число</strong>, то данный аргумент будет представлять собой <strong>массив</strong> из Length элементов.</p>
<p>Суммарная длина всех аргументов команды не должна превышать 250 байт.</p>
<p>Обработка команд производится с учётом их размера в байтах. Поэтому для обеспечения обратной совместимости с последующими версиями протокола необходимо, чтобы размер команды оставался постоянным. Для этого рекомендуется обеспечить запас по размеру команды путём добавления массива reserved.<br />
        Пример:</p>
<pre><code class="c">
typedef struct
{
  uint8_t foo;
  uint8_t reserved[41];
}
my_command_v1;
// sizeof(my_command_v1) = 1 + 41 = 42

typedef struct
{
  uint8_t foo;
  uint8_t bar[3];
  uint8_t reserved[38];
}
my_command_v1;
// sizeof(my_command_v2) = 1 + 3 + 38 = 42 = sizeof(my_command_v1)
</code></pre>
<h4>2.4. Добавить <strong>описания аргументов</strong> на русском и английском</h4>
<p>Для этого нужно нажать на кнопку <strong>Edit</strong> рядом с соответствующим аргументом в списке.  </p>
<h4>2.5 Добавить константы</h4>
<p>В случае, если какой-то из аргументов будет представлять собой некоторый набор флагов, или же просто требуется определить универсальный набор констант для прошивки МК и программы для ПК, к каждому из аргументов можно создать набор констант, который будут зафиксированы в виде макроопределений в соответствующих заголовочных файлах.</p>
<p>Имена констант рекомендуется писать в верхнем регистре.</p>
<h3>3. Добавить аксессоры</h3>
<p>Чтобы добавить аксессоры, нужно перейти на главную страницу проекта. Это можно сделать, кликнув по ссылке Home слева вверху.</p>
<h4>3.1. Определить аксессор</h4>
<p><img src="{{static_url('img/URPC_accessor_create.png')}}" alt="" /></p>
<p><strong><span class="caps">AID</span></strong> &#8211; это 3-буквенный <strong>идентификатор</strong>, который <strong>должен быть уникальным</strong> для каждого аксессора.<br />
    <span class="caps">AID</span> также не должен пересекаться с идентификаторами команд в формате G&lt;<span class="caps">AID</span>&gt; и S&lt;<span class="caps">AID</span>&gt;. То есть нельзя создавать аксессор с идентификатором <span class="caps">MID</span>, если уже определена команда с идентификатором <span class="caps">GMID</span> или <span class="caps">SMID</span>.<br />
    <span class="caps">AID</span> не чувствителен к регистру, поэтому <span class="caps">MID</span> и mId &#8211; это один и тот же идентификатор.</p>
<p><strong>Name</strong> &#8211; это имя аксессора (такое же имя будет у функции вызова этого аксессора, а также будет включено в имена типов данных, связанных с этим аксессором). Рекомендуется писать имя команды в <strong>snake_case</strong>.</p>
<p>Если аксессор создаётся только для того, чтобы обеспечить существование хотя бы одного аксессора в проекте, в поле <strong>Name</strong> рекомендуется задать имя <strong>dummy</strong>.</p>
<h4>3.2. Добавить описание аксессоров</h4>
<p>После добавления аксессора нажать <strong>Edit</strong> и <strong>добавить описание аксессора</strong> на русском и английском языках в блоке <strong>Edit accessor properties</strong> в полях <strong>english</strong> и <strong>russian</strong>.</p>
<h4>3.3. Добавить аргументы аксессора</h4>
<p><strong>Важно!</strong> для корректной работы аксессор должен содержать <strong>хотя бы один аргумент</strong></p>
<p>Процесс добавления аргументов аксессоров аналогичен добавлению аргументов команд. </p>
<h4>3.4. Добавить константы</h4>
<p>Константы аргументов аксессоров аналогичны константам аргументов команд. </p>
<h3>4. Сгенерировать исходный код проекта</h3>
<p>Чтобы сгенерировать исходный код, нужно перейти на главную страницу проекта. Это можно сделать, кликнув по ссылке Home слева вверху.</p>
<h4>4.1. Сгенерировать исходный код прошивки для МК</h4>
<p>На панели справа в разделе <strong>Firmware</strong> из выпадающего списка <strong>выбрать микроконтроллер</strong> и нажать <strong>Generate</strong>.<br />
    Сохранить архив с кодом.</p>
<h4>4.2 Сгенерировать код библиотеки</h4>
<p>На панели справа в разделе <strong>Library</strong> нажать <strong>Generate</strong>.<br />
    Сохранить архив с кодом.</p>
<h4>4.3 Сохранить параметры проекта</h4>
<p>На панели справа в разделе <strong>Project</strong> нажать <strong>Save</strong>.<br />
    Сохранить <span class="caps">JSON</span>-файл.</p>



<p><a name="Library"></a></p>
<h2>PC библиотека</h2>
<h3> Описание </h3>
<p align="justify">
Результатом работы этого генератора является клиентская библиотека, основная задача которой - предоставление
удобного C API для отправки запросов контроллеру и ожидание ответа от него. Сама библиотека предоставляется в
виде CMake или QMake -проекта, из которого могут быть сгенерированы файлы для конечной системы сборки(проект для Microsoft
Visual Studio, Code::Blocks, XCode, обычный Makefile. QMake генерирует проект для Visual Studio и обычный Makefile <a
href="https://cmake.org/cmake/help/v3.0/manual/cmake-generators.7.html">и т.д.</a>) Для лучшего ознакомления
с CMake рекомендуется посетить <a href="https://cmake.org/">официальной сайт</a>.
</p>
<h3> Инструкция по сборке CMake-проекта </h3>
<h3>Сборка под Windows</h3>
<img src="{{static_url('img/cmake_gui_instruction.png')}}"/>
<p align="justify">
<ol>
<li>Сгенерировать библиотеку нажатием кнопки "Generate", скачать её и распаковать архив</li>
<li>Запустить CMake GUI</li>
<li>Нажать кнопку "Browse Source..." и указать путь до папки с исходными кодами (в этой папке находится файл
CMakeLists.txt)
</li>
<li>Нажать кнопку "Browse Build..." и указать путь к папке, в которую будут перемещены сгенерированный в ходе
работы CMake
</li>
файлы проекта
<li>Нажать кнопку "Configure"</li>
<li>Выбрать среду для сборки. На Windows обычно используется "Visual Studio 12 2013". Стоит обратить внимание на разрядность (Win32 / Win64).
    В старых версиях Cmake она указана в общем списке после имени среды, в новых версиях Cmake 
    разрядность задаётся в отдельном списке.</li>
<li>Нажать кнопку "Generate"</li>
<li>Нажать "Finish"</li>
</ol>
Теперь у вас есть файлы проекта для интересующей вас IDE/Сборщика!

<p>Для работы библиотеки под Windows понадобятся распространяемые пакеты Visual Studio в зависимости от версии. Пакеты для Visual
    Studio скачиваются с официального сайта, для VS2013, например,
    <a href="https://www.microsoft.com/ru-RU/download/details.aspx?id=40784">здесь</a>.</p>
Заметьте, установщик зависит от битности системы.
</p>
<h3>Сборка под linux</h3>
<ol>
<li>Установить пакеты разработчика (g++, gcc, make...) через командную строку. Это можно сделать одной командой, ввести в терминале:
    <p><font face = "Terminal">sudo apt-get install build-essential</font></p>
</li>
<li>Загрузить архив с библиотекой, распаковать его</li>
<li>В директории src в распакованном архиве библиотеки запустить командную строку и выполнить cmake:
<p>
    <font face = "Terminal">
cmake -D ENABLE_XINET=ON CMakeLists.txt
    </font>
</p>
</li>
<li>В этой же директории выполнить make:</li>
    <p><font face = "Terminal">make</font></p>
<li>В результате сборки получилась библиотека .so. Чтобы ваши программы (и qt-отладчик) находили библиотеку, добавьте путь к библиотеке в переменную LD_LIBRARY_PATH.
    Например, если хотите из оболочки запустить программу, которая использует библиотеку, наберите в командной строке:</li>
    <p><font face = "Terminal">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:путь_к_директории_с_библиотекой</font></p>
<li>Готово. Для использования библиотеки в ваших программах достаточно добавить заголовочный файл <имя_протокола>.h
    (лежит в директории с распакованным архивом библиотеки)</li>
</ol>
<p></p>
<p><a name="Firmware"></a></p>
<h2>Генерация прошивки</h2>
<h4> Описание </h4>
<p align="justify">
На основе описания протокола этот генератор способен создать полноценную прошивку для целевого микроконтроллера,
тем самым уберегая программиста от участи написания одного и того же шаблонного кода из раза в раз.
</p>
<h4> Инструкция по сборке </h4>
<p align="justify">
<ul>
<li>Выбрать из выпадающего списка целевой микроконтроллер</li>
<li>Сгенерировать проект прошивки нажатием кнопки "Generate", скачать его и распаковать архив</li>
<li>Директорию с проектом нужно положить на один уровень вложенности от корневого каталога (рекомендуемая схема <i>C:\projects\&lt;директория с проектом&gt;\workspace.eww</i>)</li>
<li>Установить библиотеки необходимые для сборки проекта. Библиотеки выбираются в зависимости от целевого микроконтроллера</li>
<li>
<h5>Texas Instruments:</h5>
<h6>TI LM3S5R31</h6>
<ol>
  <li>Загрузить набор библиотек StellarisWare с <a href="https://www.ti.com/tool/SW-DRL">официального сайта</a> или из <a href="https://download.urpc.kea.su/firmware/ti/lm3s5r31/SW-LM3S-10636.exe">нашего хранилища</a></li>
  <li>Запустить загруженный установщик и установить библиотеку так, чтобы она располагалась по пути <code>C:\ti\StellarisWare</code>.</li>
</ol>
<h6>TI TM4C1294KCPDT</h6>
<ol>
  <li>Загрузить набор библиотек StellarisWare с <a href="https://www.ti.com/tool/SW-TM4C">официального сайта</a> или из <a href="https://download.urpc.kea.su/firmware/ti/tm4c1294kcpdt/SW-TM4C-2.1.2.111.exe">нашего хранилища</a></li>
  <li>Запустить загруженный установщик и установить библиотеку так, чтобы она располагалась по пути <code>C:\ti\TivaWare_C_Series-2.1.2.111</code>.</li>
</ol>
</li>
<li>
<h5>Milandr:</h5>
<ol>
<li>Распаковать содержимое архива <a href="{{static_url('files/iar-env.rar')}}">iar-env.rar</a> в каталог, где установлен IAR (для выполнения операции требуются права администратора)</li>
<li>Необходима установленная система контроля версий <a href="https://www.mercurial-scm.org/">Mercurial</a></li>
<li>Открыть командную строку (<i>Win + R</i>, в поле Open ввести cmd.exe, <i>Enter</i>), выполнить следующие команды</li>
<li><p><font face = "Terminal">cd C:\projects</font></p></li>
<li><p><font face = "Terminal">hg clone https://bitbucket.org/vitkorob/emdr1986x-std-per-lib</font></p></li>
<li><p><font face = "Terminal">cd C:\projects\emdr1986x-std-per-lib</font></p></li>
<li><p><font face = "Terminal">hg update default</font></p></li>
</ol>
</li>
<li>Запустить <i>IAR Embedded Workbench</i>, <i>File->Open->Workspace...</i>, выбрать <i>C:\projects\&lt;директория с проектом&gt;\workspace.eww</i></li>
<li>Открыть свойства проекта (<i>Alt + F7</i>)</li>
<li>В поле <i>Debugger->Setup->Driver</i> выбрать модель вашего программатора</li>
<li>На вкладке <i>Debugger->Download</i> выставить галочки как на рисунке ниже</li>
<li>Основные настройки закончены, можно скомпилировать код программы <i>F7</i>, и залить программу в микроконтроллер <i>Project->Download->Download active application</i></li>
<li>После запуска отладчика может выдаваться предупреждение о "неизвестном" ядре. Надо согласиться на ручной выбор и выбрать из предложенных ядер соответствующее ядро</li>
<li>Сделать reset микроконтроллеру, в операционной системе появится виртуальный COM-порт, поставить на него драйвера, открывать библиотекой</li>
</ul>
<img src="{{static_url('img/firmware_debugger_instruction.png')}}"/>
</p>

<p><a name="QT"></a></p>
<h2> QT-дебаггер </h2>
    <p><b>Описание</b></p>
    <p>На основании протокола генератор способен создать программу-дебаггер с графическим интерфейсом, позволяющую взаимодействовать (отправлять команды, смотреть результат) с реальным и виртуальным устройством, работающим по данному протоколу. В сгенерированном архиве лежат исходные коды программы и файл проекта Qt</p>

    <h3>Инструкция по сборке qt-отладчика</h3>
    <h3>Сборка под Windows</h3>
    <p>1. Установка Qt</p>
    <ul>
        <li>Скопировать архив qt486_msvc2013_full.7z из каталога сетевого диска Z:\Distr\Qt 4.8 	msvc2013</li>
        <li>Распаковать содержимое архива в каталог C:\Qt\, так чтобы следующий паттерн был удовлетворен C:\Qt\msvc2013\4.8.6_x64\bin\</li>
        <li><a href="https://msdn.microsoft.com/ru-ru/library/office/ee537574.aspx">Прописать в системные пути</a>: каталог C:\Qt\msvc2013\4.8.6_x64\bin\</li>
    </ul>
    <p>2. Создание проекта для Visual Studio</p>
    <ul>
        <li>Кинуть в каталог проекта файлы <code>&lt;имя проекта&gt;.dll</code>, <code>&lt;имя проекта&gt;.lib</code>, <code>&lt;имя проекта&gt;.h</code> от предварительно скомпилированной библиотеки</li>
        <li>С помощью cmake gui по аналогии со сборкой библиотеки собрать проект msvc</li>
        <li>Убедиться, что в каталоге проекта создался файл решения - <code>uRPC_debugger.sln</code></li>
    </ul>
    <p>3. Сборка Visual Studio</p>
    <ul>
        <li>Открыть в Visual Studio файл Qtd.vcxproj</li>
        <li>Скомпилировать, можно пытаться запускать</li>
    </ul>
    <h3>Сборка под Linux</h3>
    <ol>
        <li>Установить qt4 (можно и qt5) через командную строку. Для этого в командной строке ввести:
        <p><font face = "Terminal">sudo apt-get install libqt4-dev</font></p>
        </li>
        <li>Установить g++, make через командную строку. Это можно сделать одной командой:
        <p><font face = "Terminal">
            sudo apt-get install build-essential
            </font>
        </p>
        </li>
        <li>Установить cmake:
        <p><font face = "Terminal">
            sudo apt-get install cmake
            </font>
        </p>
        </li>
        <li>В директории с распакованным архивом qt-отладчика запустить cmake:
        <p><font face = "Terminal">
            cmake CMakeLists.txt
            </font>
        </p>

        <li>Не забудьте поместить заголовочный файл <имя библиотеки>.h и файл библиотеки <имя библиотеки>.so от предварительно собранной библиотеки в каталог с распакованным архивом qt-отладчика</li>
        <li>Запустить make:
        <p><font face = "Terminal">
            make
        </font>
        </p>

        <li>Дождаться окончания сборки</li>
        <li>Запустить программу, предварительно добавив в переменную окружения путь к библиотеке:
        <p>
            <font face = "Terminal">
            export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd`<p></p>
            ./Qtd
            </font>
        </p>
        Заметьте, для работы с реальным устройством могут потребоваться права root. </li>
    </ol>

    <h3>Запуск и работа с программой</h3>
    <ul>
        <li>Для работы программы требуется &lt;имя проекта&gt;.dll и dll-ки от Qt (если Qt прописана в системные пути, то Qt-шные библиотеки должны найтись сами). <br />
            Под linux потребуются библиотеки .so. Путь к библиотеке должен быть прописан в переменной окружения LD_LIBRARY_PATH (см. выше "Сборка под linux"). В некоторых версиях linux после копирования библиотеки нужно вызвать команду
        <p><font face = "Terminal">sudo ldconfig</font></p>
            для обновления кэша библиотек

        </li>
        <p></p>
        <li>Сначала нужно открыть порт. Для Windows имя порта образуется по шаблону:</li>

        <p><i>com:\\.\COMxx</i></p>
    </ul>
    <ul>
        Например, если нужен 19-й порт, написать:

        <i><p>com:\\.\<span class="caps">COM19</span></p></i>
     </ul>
    <ul>
        Для Linux:

        <i><p>com:///dev/ttyACM19</p></i>
    </ul>
    <ul>
        <li>Можно работать</li>
    </ul>
<p><a name="Documentation"></a></p>

<h2>Сборка TANGO Device серверов</h2>
<p>В настоящий момент TANGO Device сервера могут быть собраны только на Linux.</p>
<h4> Инструкция по сборке TDS на Linux</h4>
<p align="justify">
    <ul>
        <li>Для сборки понадобится CMake, компилятор C\C++ (build-essential), пакет TANGO (установить по 
            <a href="https://tango-controls.readthedocs.io/en/latest/installation/index.html">инструкции</a>)
            и собранная и установленная библиотека.
        </li>
        <li>
            В директорию с исходными кодами TANGO Device Server поместить заголовочный файл и библиотеку из собранной
            библиотеки.
        </li>
        <li>
            Запустить CMake, а затем сборку по аналогии с запуском CMake и сборкой библиотеки.
        </li>
    </ul>
</p>

<h2>Генерация документации</h2>
<h4> Описание </h4>
<p align="justify">
Результатом работы этого генератора является документация протокола в формате Textile - простого языка разметки,
позволяющего пользователям описывать сложные схемы форматирования текстовых документов без использования внешних
средств (WYSIWYG-редакторов, TEX, HTML и т.д.). Более подробно о синтаксисе и семантике языка Textile можно
узнать в <a href="https://textile-lang.com">онлайн-песочнице</a> (там же можно и потестировать сгенерированные
файлы).
</p>
<h4> Инструкция по сборке </h4>
<p align="justify">Содержимое созданных этим генератором файлов можно напрямую вставлять во все предназанченные для
Textile текстовые поля Redmine(wiki, тексты сообщений, новости и т.д.).</p>

<p><a name="Example"></a></p>
<h2>Генерация примеров</h2>
<h4>Описание</h4>
<p align="justify">
uRPC способен генерировать примеры использования команд протокола на других языках программирования.
Пока что реализовано только для Python.
Результатом работы этого генератора является файл (имя_протокола).py. В этом файле описаны все константы библиотеки,
структуры данных и переменная lib, по которой можно вызвать любую функцию библиотеки.
<h4> Инструкция по сборке </h4>
<ul>
<p align="justify">
<li>Для работы примеров python нужна сборанная библиотека.
Как собрать библиотеку, см. <a href="#Library">выше</a>. Заметьте, в Windows python импортирует только библиотеки,
собранные для Win32; значит, в cmake нужно указывать именно 32 битную версию.</li>
<li>Поместите собранную библиотеку рядом с файлами .py из сгенерированного uRPC архива Example
    (в Windows; в linux нужно либо поместить библиотеку в каталоги, где linux по умолчанию ищет библиотеки - например,
    /usb/lib, либо прописать в переменную окружения PATH новый путь)</li>
<li>Всё готово для использования. </li>
</p>
</ul>
<p align=""justify"> Пример программы, использующей функции протокола, приведён в файле testpython.py. Заметьте,
    она начинается с импорта файла py(имя_протокола).py - этот файл должен лежать в одной папке с файлом вашей программы.
    <p>Пример вызова функции протокола из python:</p>

    <pre><code class="python">
        t = set_position_t()
        t.Position = 5
        lib.set_position(device_id, byref(t))

        x_pos = get_position_t()
        result = lib.get_position(device_id, byref(x_pos))
        print("Result: " + repr(result))
        if result == Result.Ok:
            print("Position: " + repr(x_pos.Position))

    </code></pre>

    Обратите внимание на передачу аргументов: структуры передаются по ссылке, для этого используют функцию byref()
</p>
</div>
{% end %}
